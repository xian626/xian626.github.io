<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>webpack</title>
    <url>/2023/03/05/webpack/</url>
    <content><![CDATA[<p>webpack 是前端资源加载&#x2F;打包工具，它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。在做 vue 项目和 react 项目时都会可能用到，当前最火的前端构建工具之一，把前端各种资源编译打包，最后输出：js 文件、css 文件、png 文件，可以减少文件资源的请求。</p>
<h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure></div>

<ul>
<li>开发时用：-D （–save -dev）</li>
<li>开发，上线都用： -S (–save)</li>
</ul>
<h6 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h6><div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">npm i webpack@<span class="number">5</span>.<span class="number">42</span>.<span class="number">1</span> webpack-cli@<span class="number">4</span>.<span class="number">7</span>.<span class="number">2</span> -D</span><br></pre></td></tr></table></figure></div>

<h6 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h6><p>1.在项目根目创建 webpack.config .js 的 webpack 配置文件</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span> <span class="comment">//mode可选development (开发用)和production（上线用）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>2.在 package.json 的 script 节点下新增 dev 脚本</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>:&#123;<span class="string">&quot;dev&quot;</span>:<span class="string">&quot;webpack&quot;</span>&#125;<span class="comment">//可用npm run dev</span></span><br></pre></td></tr></table></figure></div>

<p>3.在终端运行 npm run dev</p>
<hr>
<h6 id="自定义打包入口与出口"><a href="#自定义打包入口与出口" class="headerlink" title="自定义打包入口与出口"></a>自定义打包入口与出口</h6><p>在 webpack.config.js 文件中通过 entry 节点指定打包的入口通过 output 指定打包的出口</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 打包入口文件</span></span><br><span class="line">  <span class="attr">entry</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;./src/index.js&#x27;</span>),</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">// 输出文件的存放路径</span></span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="comment">//输出文件的名称</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;js/main.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h6 id="webpack-中的插件"><a href="#webpack-中的插件" class="headerlink" title="webpack 中的插件"></a>webpack 中的插件</h6><p><strong>webpack-dev-server（工具）</strong><br>当修改源代码，webpack 会自动进行打包和构建<br>webpack-dev-server 生成到内存中的文件，默认放到了项目的根目录在，而且是虚拟的，不可见的。<br><strong>安装</strong></p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">npm i webpack-dev-server@<span class="number">3</span>.<span class="number">11</span>.<span class="number">1</span> -D</span><br></pre></td></tr></table></figure></div>

<p><strong>配置</strong><br>修改 webpack.json-&gt;scripts 中的 dev 命令</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;webpack serve&quot;</span>,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></div>

<p><strong>html-webpack-plugin（插件）</strong><br>可以通过此插件自定义 index.html 页面的内容<br><strong>安装</strong></p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">npm i html-webpack-plugin@<span class="number">5</span>.<span class="number">3</span>.<span class="number">2</span> -D</span><br></pre></td></tr></table></figure></div>

<p>配置(在 webpack.config.js 中）</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> htmlPlugin = <span class="keyword">new</span> <span class="title class_">HtmlPlugin</span>(&#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span>,</span><br><span class="line">  <span class="attr">filename</span>: <span class="string">&#x27;./index.html&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  <span class="attr">plugins</span>: [htmlPlugin]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h6 id="dev-server-节点"><a href="#dev-server-节点" class="headerlink" title="dev server 节点"></a>dev server 节点</h6><p>在 webpack.confg.js 配置文件中，可以通过 devserver 节点对 webpack-dev-server 插件进行更多配置</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">open</span>: <span class="literal">true</span>,<span class="comment">//初次打包后打开浏览器</span></span><br><span class="line">        <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="comment">//打包所使用的主机地址</span></span><br><span class="line">        <span class="attr">port</span>: <span class="number">80</span>,<span class="comment">//打包所用端口</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></div>

<h6 id="loader-加载器"><a href="#loader-加载器" class="headerlink" title="loader 加载器"></a>loader 加载器</h6><p><strong>安装</strong></p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">npm i style-loader@<span class="number">3</span>.<span class="number">0</span>.<span class="number">0</span> css-loader@<span class="number">5</span>.<span class="number">2</span>.<span class="number">6</span> -D</span><br></pre></td></tr></table></figure></div>

<p>在 webpack.config.js 的 moducle-&gt;rules 数据中添加 loader</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h6 id="打包处理-less-文件"><a href="#打包处理-less-文件" class="headerlink" title="打包处理 less 文件"></a>打包处理 less 文件</h6><p><strong>安装</strong></p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">npm i less-loader@<span class="number">10</span>.<span class="number">0</span>.<span class="number">1</span> less@<span class="number">4</span>.<span class="number">1</span>.<span class="number">1</span> -D</span><br></pre></td></tr></table></figure></div>

<p><strong>配置</strong><br>在 webpack.config.js 的 module-&gt;rules 数据中添加 loader 规则</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">mouder</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">      <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;less-loader&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h6 id="打包处理样式中-url-路径相关的文件"><a href="#打包处理样式中-url-路径相关的文件" class="headerlink" title="打包处理样式中 url 路径相关的文件"></a>打包处理样式中 url 路径相关的文件</h6><p><strong>安装</strong></p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">npm i url0loader@<span class="number">4</span>.<span class="number">1</span>.<span class="number">1</span>file-loader@<span class="number">6</span>.<span class="number">2</span>.<span class="number">0</span> -D</span><br></pre></td></tr></table></figure></div>

<p><strong>配置</strong><br>在 webpack.config.js 的 module-&gt;rules 数组中添加 loader</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">mouder</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.jpg|png|gif$/</span>,</span><br><span class="line">      <span class="attr">use</span>: [</span><br><span class="line">        <span class="string">&#x27;url-loader?                                              limit=170&amp;outputPath=images&#x27;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h6 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h6><p>webpack 无法处理的高级 js 语法使用 bable-loader<br><strong>安装</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i babel-loader@8.2.2 @bsbel/core@7.14.6 @babel/plugin-proposal-decorators@7.14.5 -D</span><br></pre></td></tr></table></figure></div>

<p><strong>配置</strong><br>在 webpack.config.js 的 module-&gt;rules 添加 loader</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    <span class="attr">use</span>: [<span class="string">&#x27;babel-loader&#x27;</span>],</span><br><span class="line">    <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在项目中创建 babel.confing.js 的配置文件定义 babel 的配置</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [[<span class="string">&#x27;@babel/plugin-proposal-decorators&#x27;</span>, &#123; <span class="attr">legacy</span>: <span class="literal">true</span> &#125;]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h3><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;webpack serve&quot;</span>,</span><br><span class="line">    <span class="string">&quot;bulid&quot;</span>: <span class="string">&quot;webpack --mode production&quot;</span><span class="comment">//发布</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></div>

<p>通过–model 指定参数会覆盖 webpack.config.js 中的 model 选项</p>
<p>把 js 文件统一生成到 js 目录中<br>在 webpack.config.js 中 output 中的 filename‘js&#x2F;bundle.js’<br>把 images 文件放在 image 目录中<br>修改 webpack.config.js 中的 url-loader 新增 outputPath 选项可指定图片文件的输出路径</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.jpg|png|gif$/</span>,</span><br><span class="line">        <span class="comment">// use: [&#x27;url-loader?limit=170&amp;outputPath=images&#x27;]</span></span><br><span class="line">        <span class="attr">use</span>: &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">limit</span>: <span class="number">170</span>,</span><br><span class="line">            <span class="attr">outputPath</span>: <span class="string">&#x27;images&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure></div>

<h5 id="打包自动清理-dist-下的旧文件"><a href="#打包自动清理-dist-下的旧文件" class="headerlink" title="打包自动清理 dist 下的旧文件"></a>打包自动清理 dist 下的旧文件</h5><p>安装</p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">npm i clean-webpack-plugin@<span class="number">3</span>.<span class="number">0</span>.<span class="number">0</span> -D</span><br></pre></td></tr></table></figure></div>

<p>配置<br>按需导入插件,得到插件的构造函数，创建插件的实例化对象</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">CleanWebpackPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> cleanPlugin = <span class="keyword">new</span> <span class="title class_">CleanWebpackPlugin</span>()</span><br></pre></td></tr></table></figure></div>

<p>把创建的实例对象挂载到 plugins 节点中</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="attr">plugins</span>: [htmlPlugin, cleanPlugin],</span><br></pre></td></tr></table></figure></div>

<h6 id="Source-Map"><a href="#Source-Map" class="headerlink" title="Source Map"></a>Source Map</h6><p>是一个信息文件，存在位置信息，<br>在 webpack.config.js 中加 devtool:”eval-source-map,”(开发用)<br>只定位行号，不显示源码<br>devtool:”nosources-sours-map 或 SourceMap”（上线用）</p>
]]></content>
  </entry>
  <entry>
    <title>ES6~ES13</title>
    <url>/2023/03/18/ES6~ES13/</url>
    <content><![CDATA[<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="let-声明变量"><a href="#let-声明变量" class="headerlink" title="let 声明变量"></a>let 声明变量</h2><p>let 关键字声明变量是在 es6 中引入的 ，使用 let 声明变量主要有以下特点：</p>
<ul>
<li>使用 let 声明的变量具有块级作用域</li>
<li>使用 let 声明的变量没有变量提升</li>
<li>使用 let 声明的变量具有暂时性死区</li>
<li>let 声明的变量不能重复声明</li>
</ul>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>const 是 ES6 新增的关键字，作用是声明一个只读的常量。注意，常量标识符一般用大写字母表示，使用 const 声明常量主要有以下特点：</p>
<ul>
<li>声明时必须立即赋值，之后不允许修改常量值</li>
<li>不允许重复声明</li>
<li>块儿级作用域</li>
<li>不存在变量提升</li>
</ul>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>解构赋值是对赋值运算符的扩展。他是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。在代码书写上简洁且易读，语义更加清晰明了；也方便了复杂对象中数据字段获取</p>
<ul>
<li>数组模型的解构（Array）<br>基本</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// a = 1 // b = 2 // c = 3</span></span><br></pre></td></tr></table></figure></div>

<p>可嵌套</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, [[b], c]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]] <span class="comment">// a = 1 // b = 2 // c = 3</span></span><br></pre></td></tr></table></figure></div>

<p>可忽略</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, , b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// a = 1 // b = 3</span></span><br></pre></td></tr></table></figure></div>

<p>不完全解构</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">1</span>, b] = [] <span class="comment">// a = 1, b = undefined</span></span><br></pre></td></tr></table></figure></div>

<p>剩余运算符</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">//a = 1 //b = [2, 3]</span></span><br></pre></td></tr></table></figure></div>

<p>字符串等在数组的解构中，解构的目标若为可遍历对象，皆可进行解构赋值。可遍历对象即实现 Iterator 接口的数据。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span> <span class="comment">// a = &#x27;h&#x27; // b = &#x27;e&#x27; // c = &#x27;l&#x27; // d = &#x27;l&#x27; // e = &#x27;o&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>解构默认值</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">2</span>] = [<span class="literal">undefined</span>] <span class="comment">// a = 2</span></span><br></pre></td></tr></table></figure></div>

<p>当解构模式有匹配结果，且匹配结果是 undefined 时，会触发默认值作为返回结果。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [] <span class="comment">// a = 3, b = 3</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>] <span class="comment">// a = 1, b = 1</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>, <span class="number">2</span>] <span class="comment">// a = 1, b = 2</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>对象模型的解构（Object）<br>基本</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125; <span class="comment">// foo = &#x27;aaa&#x27; // bar = &#x27;bbb&#x27;</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">baz</span>: foo &#125; = &#123; <span class="attr">baz</span>: <span class="string">&#x27;ddd&#x27;</span> &#125; <span class="comment">// foo = &#x27;ddd</span></span><br></pre></td></tr></table></figure></div>

<p>可嵌套可忽略</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">p</span>: [<span class="string">&#x27;hello&#x27;</span>, &#123; <span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span> &#125;] &#125;</span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">  <span class="attr">p</span>: [x, &#123; y &#125;]</span><br><span class="line">&#125; = obj <span class="comment">// x = &#x27;hello&#x27; // y = &#x27;world&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">p</span>: [<span class="string">&#x27;hello&#x27;</span>, &#123; <span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span> &#125;] &#125;</span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">  <span class="attr">p</span>: [x, &#123;&#125;]</span><br><span class="line">&#125; = obj <span class="comment">// x = &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>不完全解构</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">p</span>: [&#123; <span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span> &#125;] &#125;</span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">  <span class="attr">p</span>: [&#123; y &#125;, x]</span><br><span class="line">&#125; = obj <span class="comment">// x = undefined // y = &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>剩余运算符</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; a, b, ...rest &#125; = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span> &#125; <span class="comment">// a = 10 // b = 20 // rest = &#123;c: 30, d: 40&#125;</span></span><br></pre></td></tr></table></figure></div>

<p>解构默认值</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; a = <span class="number">10</span>, b = <span class="number">5</span> &#125; = &#123; <span class="attr">a</span>: <span class="number">3</span> &#125; <span class="comment">// a = 3; b = 5;</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">a</span>: aa = <span class="number">10</span>, <span class="attr">b</span>: bb = <span class="number">5</span> &#125; = &#123; <span class="attr">a</span>: <span class="number">3</span> &#125; <span class="comment">// aa = 3; bb = 5;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>模板字符串相当于加强版的字符串，用反引号  ,除了作为普通字符串，还可以用来定义多行字符串，还可以在字符串中加入变量和表达式。<br>多行字符串:</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string1 = <span class="string">`Hey, can you stop angry now?`</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(string1) <span class="comment">// Hey, // can you stop angry now?</span></span><br></pre></td></tr></table></figure></div>

<p>字符串插入变量和表达式。变量名写在 ${} 中，${} 中可以放入 JavaScript 表达式。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Mike&#x27;</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">27</span></span><br><span class="line"><span class="keyword">let</span> info = <span class="string">`My Name is <span class="subst">$&#123;name&#125;</span>,I am <span class="subst">$&#123;age + <span class="number">1</span>&#125;</span> years old next year.`</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info)</span><br><span class="line"><span class="comment">// My Name is Mike,I am 28 years old next year.</span></span><br></pre></td></tr></table></figure></div>

<p>字符串中调用函数：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;have fun!&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> string2 = <span class="string">`Game start,<span class="subst">$&#123;f()&#125;</span>`</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(string2)</span><br><span class="line"><span class="comment">// Game start,have fun!</span></span><br></pre></td></tr></table></figure></div>

<p>注意要点:<br>模板字符串中的换行和空格都是会被保留的<br>标签模板<br>是一个函数的调用，其中调用的参数是模板字符串。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">alert<span class="string">`Hello world!`</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;Hello world!&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<h2 id="字符串与数值拓展"><a href="#字符串与数值拓展" class="headerlink" title="字符串与数值拓展"></a>字符串与数值拓展</h2><ul>
<li>字符串</li>
</ul>
<p>includes()：返回布尔值，判断是否找到参数字符串。<br>startsWith()：返回布尔值，判断参数字符串是否在原字符串的头部。<br>endsWith()：返回布尔值，判断参数字符串是否在原字符串的尾部。<br>注意点：<br>这三个方法只返回布尔值，如果需要知道子串的位置，还是得用 indexOf 和 lastIndexOf 。这三个方法如果传入了正则表达式而不是字符串，会抛出错误。而 indexOf 和 lastIndexOf 这两个方法，它们会将正则表达式转换为字符串并搜索它。<br>以上三个方法都可以接受两个参数，需要搜索的字符串，和可选的搜索起始位置索引<br>repeat()：返回新的字符串，表示将字符串重复指定次数返回。<br>padStart：返回新的字符串，表示用参数字符串从头部（左侧）补全原字符串。<br>padEnd：返回新的字符串，表示用参数字符串从尾部（右侧）补全原字符串。<br>以上两个方法接受两个参数，第一个参数是指定生成的字符串的最小长度，第二个参数是用来补全的字符串。如果没有指定第二个参数，默认用空格填充。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;h&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">5</span>, <span class="string">&#x27;o&#x27;</span>)) <span class="comment">// &quot;ooooh&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;h&#x27;</span>.<span class="title function_">padEnd</span>(<span class="number">5</span>, <span class="string">&#x27;o&#x27;</span>)) <span class="comment">// &quot;hoooo&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;h&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">5</span>)) <span class="comment">// &quot;    h&quot;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>数值<br>二进制表示法新写法: 前缀 0b 或 0B 。<br>八进制表示法新写法: 前缀 0o 或 0O 。<br>Number.EPSILON  属性表示 1 与大于 1 的最小浮点数之间的差。它的值接近于  2.2204460492503130808472633361816E-16，或者  2-52。测试数值是否在误差范围内:</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">// false// 在误差范围内即视为相等</span></span><br><span class="line">equal = <span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="number">0.1</span> - <span class="number">0.3</span> + <span class="number">0.2</span>) &lt; <span class="title class_">Number</span>.<span class="property">EPSILON</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<p>最大&#x2F;最小安全整数<br>安全整数安全整数表示在 JavaScript 中能够精确表示的整数，安全整数的范围在 2 的 -53 次方到 2 的 53 次方之间（不包括两个端点），超过这个范围的整数无法精确表示。<br>最大安全整数安全整数范围的上限，即 2 的 53 次方减 1 。<br>最小安全整数安全整数范围的下限，即 2 的 53 次方减 1 的负数。</p>
<ul>
<li>方法<br>Number.isFinite()：用于检查一个数值是否为有限的（ finite ），即不是 Infinity<br>从全局移植到 Number 对象的方法逐步减少全局方法，用于全局变量的模块化。方法的行为没有发生改变。Number.parseInt()用于将给定字符串转化为指定进制的整数。<br>Math.cbrt 用于计算一个数的立方根。<br>Math.imul 两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。<br>Math.hypot 用于计算所有参数的平方和的平方根。<br>Math.clz32 用于返回数字的 32 位无符号整数形式的前导 0 的个数。<br>Math.trunc 用于返回数字的整数部分<br>Math.fround 用于获取数字的 32 位单精度浮点数形式。<br>Math.sign 判断数字的符号（正、负、0）<br>Math.expm1()用于计算 e 的 x 次方减 1 的结果，即 Math.exp(x) - 1<br>…<br>详见<a href="www.runoob.com/w3w3cnote/es6-number.html">ECMAScript 6.0</a></li>
</ul>
<h2 id="数组拓展"><a href="#数组拓展" class="headerlink" title="数组拓展"></a>数组拓展</h2><ul>
<li>array.forEach()<br>循环遍历数组中的每一项</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">array.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;<span class="comment">//数组操作不能return 值&#125;)</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>array.map()<br>map 方法和 forEach 每次执行匿名函数都支持 3 个参数，参数分别是 item（当前每一项）、index（索引值）、arr（原数组），但是 map 返回一个新数组,原数组不影响；</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.<span class="title function_">map</span>(<span class="function">(<span class="params">iitem, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">//通过return 返回想要的东西</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>array.filter 筛选数组中符合条件的项，返回一个新数组</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> result = arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;<span class="keyword">return</span> item&gt;<span class="number">2</span>;&#125;）</span><br></pre></td></tr></table></figure></div>

<ul>
<li>array.some()和 array.every()<br>一个数组是否满足什么条件，返回一个布尔值</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>];<span class="keyword">let</span> result = arr.<span class="title function_">some</span>(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;<span class="keyword">return</span> item&gt;<span class="number">2</span>;&#125;）</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>];<span class="keyword">let</span> result = arr.<span class="title function_">every</span>(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;<span class="keyword">return</span> item&gt;<span class="number">2</span>;&#125;）</span><br><span class="line"><span class="comment">//false</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>array.find()find（）<br>方法只会找到第一个符合的，找到之后就会直接返回，就算下面还有符合要求的，也不会再找下去</li>
<li>reduce()</li>
</ul>
<p>reduce()方法，一般用于求和，它是一个比较特殊的方法，一共有四个参数。 reduce()方法最重要的作用就是累加的操作，将数组的每个元素从左往右依次执行累加器，返回最终的处理结果。不会影响原数组。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="comment">// sum:上一次的值，item：当前值，index：当前索引，arr:原数组</span></span><br><span class="line"><span class="keyword">const</span> result = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (sum += item)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 这里的0，是一个初始值，意思是从0开始计算</span></span><br><span class="line"><span class="comment">// 因为我这里做的是加法运算，所以返回的是累加的和</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></div>

<h2 id="对象拓展"><a href="#对象拓展" class="headerlink" title="对象拓展"></a>对象拓展</h2><ul>
<li>Object.assign（）<br>通过复制一个或多个对象来创建一个新的对象<br>如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性。如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。<br>assign 的属性拷贝是浅拷贝<br>拓展运算符（…）用于取出参数对象所有可遍历属性然后拷贝到当前对象。自定义的属性在拓展运算符后面，则拓展运算符对象内部同名的属性将被覆盖掉。</li>
<li>Object.is(value1, value2)<br>用来比较两个值是否严格相等，与（&#x3D;&#x3D;&#x3D;）基本类似。</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(+<span class="number">0</span>, -<span class="number">0</span>) <span class="comment">//false</span></span><br><span class="line">;+<span class="number">0</span> === -<span class="number">0</span> <span class="comment">//true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>) <span class="comment">//true</span></span><br><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>Object.defineProperty()<br>方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。<br><code>Object.defineProperty(obj, prop, descriptor)</code><br>obj 要定义属性的对象。<br>prop 要定义或修改的属性的名称或  Symbol 。<br>descriptor 要定义或修改的属性描述符。</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">数据描述符:</span><br><span class="line"><span class="title class_">Configurable</span>:能否<span class="keyword">delete</span>删除属性(默认值<span class="literal">false</span>)</span><br><span class="line"><span class="title class_">Writable</span>: 能否修改属性的值(默认值<span class="literal">false</span>)</span><br><span class="line"><span class="title class_">Value</span>: 属性的值 (默认值<span class="literal">undefined</span>)</span><br><span class="line"><span class="title class_">Enumerable</span>: 该属性是否为可枚举 (默认值<span class="literal">false</span>)</span><br><span class="line">存取描述符:</span><br><span class="line">存取描述符属性 <span class="title class_">Enumerable</span> 和 <span class="title class_">Configurable</span> 和数据描述符一致</span><br><span class="line"><span class="title class_">Get</span>: 提供一个getter方法，访问调用</span><br><span class="line"><span class="title class_">Set</span>: 提供一个setter方法，修改时调用</span><br><span class="line"><span class="comment">// Object.defineProperty</span></span><br><span class="line">  <span class="keyword">var</span>  obj = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&quot;name&quot;</span>,&#123;</span><br><span class="line">    <span class="title class_">Configurable</span> : <span class="literal">false</span> ,</span><br><span class="line">    <span class="title class_">Enumerable</span>: <span class="literal">true</span> ,</span><br><span class="line">    <span class="title class_">Writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="title class_">Value</span>: <span class="string">&quot;无法被修改的值&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>) <span class="comment">// 无法被修改的值</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>Object.defineProperties(obj.props)<br>将所有可枚举属性的值从一个或多个对象复制到目标对象，并返回目标对象</li>
<li>Object.getOwnPropertyDescriptor(obj,prop)<br>获取对象中的一个属性描述<br>参数:obj:目标对象 prop:目标属性名称</li>
<li>Object.getOwnPropertyDescriptors(obj)<br>获取目标对象中的所有属性描述，如果没有任何自身属性，则返回空对象</li>
<li>Object.entries(obj)<br>返回自身可枚举属性的键值对，顺序与 for in 一致，返回一个二维数组 [[key:value]]</li>
<li>Object.freeze(obj)<br>冻结：一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性 Enumerable、可配置性 Configurable、可写性 Writable，以及不能修改已有属性的值 Value。此外，冻结一个对象后该对象的原型也不能被修改。</li>
<li>Object.isFrozen(obj)<br>返回布尔值，判断对象是否被冻结</li>
<li>Object.getOwnPropertyNames(obj)<br>返回指定对象所有属性，同时也包括不可枚举属性组成的数组(该方法无法返回对象 Symbol 属性)</li>
<li>Object.keys(obj)<br>获取一个对象中所有的 key 值 (除了不可枚举属性和 Symbol 属性)</li>
<li>Object.getOwnPropertySymbols(obj)<br>返回一个给定对象自身的所有 Symbol 属性的数组</li>
<li>Object.getPrototypeOf(obj)<br>返回指定对象的原型对象</li>
<li>Object.is(Value1 , Value2)<br>判断两个值是否为”相同的值”<br>相同的值： 1.都是 undefined、true、false、null 2.相同字符串 3.相同对象，且处于同一个引用</li>
<li>Object.isExtensible(obj)<br>判断对象是否具备可扩展性，返回布尔值</li>
<li>Object.setPrototypeOf(obj,property)<br>  obj: 目标对象<br>    property: 新原型(对象)<br>    注意: 应该避免更改对象的 property，这会影响其性能，相反，可以使用 Object.create()来创建你想要[[prototyoe]]新对象</li>
<li>Object.create(obj，propertiesObject)<br>创建一个新对象，使用现有的对象来提供新创建对象的<strong>proto</strong></li>
<li>Object.isSealed(obj)<br>返回 boolean， 判断对象是否为封闭对象</li>
<li>Object.Seal(obj)<br>封闭对象：无法删除旧属性或添加新属性，但是可以修改旧属性</li>
<li>typeoftypeof<br>常用来判断基本数据类型，无法做到准确的判断对象类型，返回值字符串</li>
<li>instanceof<br>ES 6 新增，为了解决 typeof 无法检查出具体对象类型，返回布尔值<br>instanceof 的本质：检测构造函数（右边）的 prototype 属性是否出现在某个实例对象（左边）的原型链上<br>语法：Object instanceof Contrusctor<br>Object : 实例对象<br>Contrusctor：构造函数<br>contructor 它始终指向它的构造函数<br>缺陷：undefined 和 null 都是无效的对象，没有 contructor 属性，所以无法判断</li>
<li>Object.prototype.toString.call()<br>通过 Object.prototype.toString 返回对象类型字符串，判断类型<br>建议：加上 call() 改变 this 指向，因为如果在原型上定义了 toString 方法，this 的指向会指向为原型定义的方法，可能达不到预期目的</li>
</ul>
<h2 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h2><ul>
<li>参数默认值</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">aaa</span>(<span class="params">a = <span class="string">&#x27;aaa&#x27;</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">aaa</span>() <span class="comment">//结果：aaa</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>rest 参数剩余参数</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">//1,2,3,4,5</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">...arg</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">//1,2,3,4,5</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>name 属性<br><code>console.log(test.name) //test</code></li>
<li>箭头函数</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">test</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>() <span class="comment">//test</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">test1</span> = (<span class="params"></span>) =&gt; <span class="string">&#x27;11111111&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test1) <span class="comment">//11111111</span></span><br></pre></td></tr></table></figure></div>

<p>如果只有一个参数可以省略（）<br>无法访问 arguments 无法 new<br>this 没用 this，this 指向父作用域</p>
<h2 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h2><p>Symbol 是 ES6 中引入的一种新的基本数据类型，用于表示一个独一无二的值。它是 JavaScript 中的第七种数据类型，与 undefined、null、Number（数值）、String（字符串）、Boolean（布尔值）、Object（对象）并列。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Symbol</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1, <span class="keyword">typeof</span> s1)</span><br><span class="line"><span class="comment">// 添加标识的Symbol</span></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> s2_2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s2 === s2_2) <span class="comment">//false</span></span><br><span class="line"><span class="comment">// 使用Symbol for定义</span></span><br><span class="line"><span class="keyword">let</span> s3 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> s3_2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s3 === s3_2) <span class="comment">//true,使用symbol.for()来实现</span></span><br></pre></td></tr></table></figure></div>

<h2 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator 迭代器"></a>Iterator 迭代器</h2><p>Iterator 的作用有三个：<br>一是为各种数据结构，提供一个统一的、简便的访问接口；<br>二是使得数据结构的成员能够按某种次序排列；<br>三是 ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 循环<br>Iterator 的遍历过程是这样的:<br>（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。<br>（2）第一次调用指针对象的 next 方法，可以将指针指向数据结构的第一个成员。<br>（3）第二次调用指针对象的 next 方法，指针就指向数据结构的第二个成员。<br>（4）不断调用指针对象的 next 方法，直到它指向数据结构的结束位置。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i.<span class="title function_">next</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i.<span class="title function_">next</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i.<span class="title function_">next</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i.<span class="title function_">next</span>())</span><br></pre></td></tr></table></figure></div>

<p>ES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性，或者说，一个数据结构只要具有 Symbol.iterator 属性，就可以认为是“可遍历的”（iterable）。Symbol.iterator 属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。<br>原生默认具备 Iterator 接口的数据结构如下：<br>Array、Set、Map、String、arguments 对象、NodeList 对象<br>使对象可迭代</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">code</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">mas</span>: <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">next</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">data</span>[index++],</span><br><span class="line">          <span class="attr">done</span>: index === <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">length</span> + <span class="number">1</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...obj])</span><br><span class="line"><span class="keyword">const</span> iter = obj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>())</span><br></pre></td></tr></table></figure></div>

<h2 id="Set-结构"><a href="#Set-结构" class="headerlink" title="Set 结构"></a>Set 结构</h2><p>它类似于数组，但成员的值都是唯一的，没有重复的值。<br>size：返回 Set 实例的成员总数。<br>Set.prototype.add(value)：添加某个 value。<br>Set.prototype.delete(value)：删除某个 value，返回一个布尔值，表示删除是否成功。<br>Set.prototype.has(value)：返回一个布尔值，表示该值是否为 Set 的成员。<br>Set.prototype.clear()：清除所有成员，没有返回值。<br>Set.prototype.keys()：返回键名的遍历器<br>Set.prototype.values()：返回键值的遍历器<br>Set.prototype.entries()：返回键值对的遍历器<br>Set.prototype.forEach()：遍历每个成员</p>
<ul>
<li>复杂数据结构去重</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">uni</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> id = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(item)</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="title function_">has</span>(id)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.<span class="title function_">add</span>(id)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Map-结构"><a href="#Map-结构" class="headerlink" title="Map 结构"></a>Map 结构</h2><p>类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。<br>size：返回 Map 结构的成员总数。<br>Map.prototype.set(key,value)：添加 key 对应得 value，返回 Map 结构本身。<br>Map.prototype.get(key)：获取 key 对应的 value<br>Map.prototype.delete(key)：删除某个键（键名+键值）<br>Map.prototype.has(key)：某个键是否在当前 Map 对象之中。<br>Map.prototype.clear()：清除所有成员，没有返回值。<br>Map.prototype.keys()：返回键名的遍历器。<br>Map.prototype.values()：返回键值的遍历器。<br>Map.prototype.entries()：返回所有成员的遍历器。<br>Map.prototype.forEach()：遍历 Map 的所有成员</p>
<h2 id="Proxy-代理"><a href="#Proxy-代理" class="headerlink" title="Proxy 代理"></a>Proxy 代理</h2><p>Proxy 如其名， 它的作用是在对象和和对象的属性值之间设置一个代理，获取该对象的值或者设置该对象的值， 以及实例化等等多种操作， 都会被拦截住， 经过这一层我们可以统一处理，我们可以认为它就是“代理器”</p>
<ul>
<li>get 方法</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> target[prop]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>set 方法</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> target[prop]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, prop, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&#x27;data&#x27;</span>) &#123;</span><br><span class="line">      box.<span class="property">innerHTML</span> = value</span><br><span class="line">    &#125;</span><br><span class="line">    target[prop] = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>has 方法</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  <span class="attr">_prop</span>: <span class="string">&#x27;内部数据&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> target[prop]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, prop, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&#x27;data&#x27;</span>) &#123;</span><br><span class="line">      box.<span class="property">innerHTML</span> = value</span><br><span class="line">    &#125;</span><br><span class="line">    target[prop] = value</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key <span class="keyword">in</span> target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>this 问题</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = target[key] <span class="comment">// 遇到 Function 都手动绑定一下 this</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Function</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`访问<span class="subst">$&#123;value&#125;</span>方法了`</span>)</span><br><span class="line">      <span class="keyword">return</span> value.<span class="title function_">bind</span>(target) <span class="comment">//不能 是 call apply</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.<span class="title function_">add</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></div>

<p>Proxy 本质上属于元编程非破坏性数据劫持，在原对象的基础上进行了功能的衍生而又不影响原对象，符合松耦合高内聚的设计理念。</p>
<h2 id="Reflect-对象"><a href="#Reflect-对象" class="headerlink" title="Reflect 对象"></a>Reflect 对象</h2><p>Reflect 可以用于获取目标对象的行为，它与 Object 类似，但是更易读，为操作对象提供了一种更优雅的方式。它的方法与 Proxy 是对应的。</p>
<ul>
<li>Object 的某些方法</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;kerwin&#x27;</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>修改某些 Object 方法返回结果</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, property, attributes) <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// fail</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target, property, attributes)) &#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// fail</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>命令式变为函数行为</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kerwin&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//老写法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> obj) <span class="comment">//true</span></span><br><span class="line"><span class="comment">//新写法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">has</span>(obj, <span class="string">&#x27;name&#x27;</span>)) <span class="comment">//true</span></span><br><span class="line"><span class="comment">//老写法</span></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">name</span></span><br><span class="line"><span class="comment">//新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>配合 Proxy</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key) <span class="comment">// 遇到 Function 都手动绑定一下 this</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Function</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`访问<span class="subst">$&#123;value&#125;</span>方法了`</span>)</span><br><span class="line">      <span class="keyword">return</span> value.<span class="title function_">bind</span>(target) <span class="comment">//不能 是 call apply</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.<span class="title function_">add</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(arr, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get&#x27;</span>, key)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set&#x27;</span>, key, value)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.<span class="title function_">push</span>(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// 能够打印出很多内容</span></span><br><span class="line"><span class="comment">// get push     (寻找 proxy.push 方法)</span></span><br><span class="line"><span class="comment">// get length   (获取当前的 length)</span></span><br><span class="line"><span class="comment">// set 3 4      (设置 proxy[3] = 4)</span></span><br><span class="line"><span class="comment">// set length 4 (设置 proxy.length = 4)</span></span><br></pre></td></tr></table></figure></div>

<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise 是异步编程的一种解决方案，比传统的解决方案回调函数, 更合理和更强大。ES6 将其写进了语言标准，统一了用法，原生提供了 Promise 对象 。<br>指定回调函数方式更灵活易懂。<br>解决异步 回调地狱 的问题。<br>回调地狱<br>当一个回调函数嵌套一个回调函数的时候<br>就会出现一个嵌套结构<br>当嵌套的多了就会出现回调地狱的情况<br>比如我们发送三个 ajax 请求<br>第一个正常发送<br>第二个请求需要第一个请求的结果中的某一个值作为参数<br>第三个请求需要第二个请求的结果中的某一个值作为参数</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">ajax</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;我是第一个请求&#x27;</span>,</span><br><span class="line">  success (res) &#123;</span><br><span class="line">    <span class="comment">// 现在发送第二个请求</span></span><br><span class="line">    <span class="title function_">ajax</span>(&#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&#x27;我是第二个请求&#x27;</span>，</span><br><span class="line">      <span class="attr">data</span>: &#123; <span class="attr">a</span>: res.<span class="property">a</span>, <span class="attr">b</span>: res.<span class="property">b</span> &#125;,</span><br><span class="line">      success (res2) &#123;</span><br><span class="line">        <span class="comment">// 进行第三个请求</span></span><br><span class="line">        <span class="title function_">ajax</span>(&#123;</span><br><span class="line">          <span class="attr">url</span>: <span class="string">&#x27;我是第三个请求&#x27;</span>,</span><br><span class="line">          <span class="attr">data</span>: &#123; <span class="attr">a</span>: res2.<span class="property">a</span>, <span class="attr">b</span>: res2.<span class="property">b</span> &#125;,</span><br><span class="line">              success (res3) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(res3)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p>回调地狱，其实就是回调函数嵌套过多导致的,<br>当代码成为这个结构以后，已经没有维护的可能了<br>Promise 使用<br>语法：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// resolve 表示成功的回调</span></span><br><span class="line">  <span class="comment">// reject 表示失败的回调</span></span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">    <span class="comment">// 成功的函数</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="comment">// 失败的函数</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></div>

<p>Promise 对象的状态<br>Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态:</p>
<ul>
<li>异步操作未完成（pending）</li>
<li>异步操作成功（fulfilled）</li>
<li>异步操作失败（rejected）</li>
</ul>
<p>这三种的状态的变化途径只有两种。</p>
<ul>
<li>从“未完成”到“成功”</li>
<li>从“未完成”到“失败”</li>
</ul>
<p>一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise 实例的状态变化只可能发生一次。<br>因此，Promise 的最终结果只有两种。<br>异步操作成功，Promise 实例传回一个值（value），状态变为 fulfilled。<br>异步操作失败，Promise 实例抛出一个错误（error），状态变为 rejected。</p>
<ul>
<li>Promise.all</li>
</ul>
<p>Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。<br>javascript<br>const p &#x3D; Promise.all([p1, p2, p3]);<br>p 的状态由 p1,p2,p3 决定，分成两种情况：<br>（1）只有 p1、p2、p3 的状态都变成 fulfilled，p 的状态才会变成 fulfilled，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数。<br>（2）只要 p1、p2、p3 之中有一个被 rejected，p 的状态就变成 rejected，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数。</p>
<ul>
<li>Promise.race</li>
</ul>
<p>Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。<br>javascript<br><code>const p = Promise.race([p1, p2, p3]);</code><br>上面代码中，只要 p1、p2、p3 之中有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数。</p>
<h2 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h2><p>Generator 函数是 ES6 提供的一种异步编程解决方案<br>Generator 函数是一个状态机，封装了多个内部状态。<br>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  g1 = <span class="keyword">yield</span> <span class="number">11</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(g1)</span><br><span class="line">  g2 = <span class="keyword">yield</span> <span class="number">22</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(g2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> gen = <span class="title function_">generator</span>()</span><br><span class="line"><span class="keyword">let</span> f1 = gen.<span class="title function_">next</span>(<span class="number">11111111111111</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f1)</span><br><span class="line"><span class="keyword">let</span> f2 = gen.<span class="title function_">next</span>(<span class="number">2222222222222222</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f2)</span><br><span class="line"><span class="keyword">let</span> f3 = gen.<span class="title function_">next</span>(<span class="number">33333333333333333</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f3)</span><br><span class="line"><span class="comment">//object</span></span><br><span class="line"><span class="comment">//2222222222222222</span></span><br><span class="line"><span class="comment">//object</span></span><br><span class="line"><span class="comment">//33333333333333333</span></span><br><span class="line"><span class="comment">//object</span></span><br></pre></td></tr></table></figure></div>

<p>yield(产出)表达式是暂停执行的标记，而 next 方法可以恢复执行<br>异步流程</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手动版本</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res1 = <span class="keyword">yield</span> <span class="title function_">ajax</span>(<span class="string">&#x27;1.json&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res1)</span><br><span class="line">  <span class="keyword">let</span> res2 = <span class="keyword">yield</span> <span class="title function_">ajax</span>(<span class="string">&#x27;2.json&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>()</span><br><span class="line">g.<span class="title function_">next</span>().<span class="property">value</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  g.<span class="title function_">next</span>(data).<span class="property">value</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    g.<span class="title function_">next</span>(data)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动版本</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res1 = <span class="keyword">yield</span> <span class="title function_">ajax</span>(<span class="string">&#x27;1.json&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res1)</span><br><span class="line">  <span class="keyword">let</span> res2 = <span class="keyword">yield</span> <span class="title function_">ajax</span>(<span class="string">&#x27;2.json&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">AutoRun</span>(<span class="params">gen</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> g = <span class="title function_">gen</span>()</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = g.<span class="title function_">next</span>(data)</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">done</span>) <span class="keyword">return</span></span><br><span class="line">    res.<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">      <span class="title function_">next</span>(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">AutoRun</span>(gen)</span><br></pre></td></tr></table></figure></div>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul>
<li>类的写法</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// function Person(name ,age)&#123;</span></span><br><span class="line">  <span class="comment">//   this.name=name</span></span><br><span class="line">  <span class="comment">//   this.age=age</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// Person.prototype.say=function()&#123;</span></span><br><span class="line">  <span class="comment">//   console.log(this.name,this.age);</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// let obj=new Person(&quot;zs&quot;,18)</span></span><br><span class="line">  <span class="comment">// obj.say()</span></span><br><span class="line">  <span class="comment">//Symbol是ES6中引入的一种新的基本数据类型，用于表示一个独一</span></span><br><span class="line">  <span class="comment">//无二的值。它是JavaScript中的第七种数据类型，与undefined、</span></span><br><span class="line">  <span class="comment">//null、Number（数值）、String（字符串）、Boolean（布尔值）、</span></span><br><span class="line">  <span class="title class_">Object</span>（对象）并列。</span><br><span class="line">  <span class="keyword">let</span> s=<span class="title class_">Symbol</span>(<span class="string">&quot;say&quot;</span>)</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name,age</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">name</span>=name</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">age</span>=age</span><br><span class="line">    &#125;</span><br><span class="line">    [s]()&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>,<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> obj=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;zs&quot;</span>,<span class="number">18</span>)</span><br><span class="line">  obj[s]()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>);</span><br></pre></td></tr></table></figure></div>

<p>注：prototype 是构造函数的一个属性，它指向了一个对象。这个对象的所有属性和方法都可以被该构造函数的实例继承。 proto 是每个对象都有的属性，它指向了这个对象的原型对象。即指向了该对象的构函数的 prototype 属性指向的对象。 总的来说，prototype 是构造函数的属性，<strong>proto</strong>是对象的属性。</p>
<ul>
<li>get()和 set()方法</li>
</ul>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">             </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">             </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">             </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">             </span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">             </span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">                 </span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">             </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">constructor</span>(<span class="params">name, age, list</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">this</span>.<span class="property">name</span> = name</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">this</span>.<span class="property">age</span> = age</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">this</span>.<span class="property">ele</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">`.<span class="subst">$&#123;list&#125;</span>`</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">get</span> <span class="title function_">age</span>() &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">set</span> <span class="title function_">age</span>(<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set&#x27;</span>, data)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">get</span> <span class="title function_">html</span>() &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">ele</span>.<span class="property">innerHTML</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">set</span> <span class="title function_">html</span>(<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">this</span>.<span class="property">ele</span>.<span class="property">innerHTML</span> = data.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="string">`&lt;li&gt;<span class="subst">$&#123;item&#125;</span>&lt;/li&gt;`</span>).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;zs&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;list&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>静态属性和方法</li>
</ul>
<p>定在在类上，而不是定义在类的原型上，类可以调用，类的实例不能调用的方法就叫做静态方法在实际应用中，静态方法主要用于操作静态属性。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// ES6写法</span></span><br><span class="line">  <span class="keyword">static</span> myname = <span class="string">&#x27;ls&#x27;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">mySay</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">say</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>, <span class="variable language_">this</span>.<span class="property">age</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">// 普通写法 // Person.myname=&quot;ls&quot; // Person.mySay=function()&#123; //   console.log(this); // &#125;</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;zs&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">mySay</span>()</span><br></pre></td></tr></table></figure></div>

<ul>
<li>继承</li>
</ul>
<p>创建的子类将继承超类的所有属性和方法，包括构造函数及方法的实现。记住，所有属性和方法都是公用的，因此子类可直接访问这些方法。子类还可添加超类中没有的新属性和方法，也可以覆盖超类的属性和方法。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="title class_">Symbol</span>(<span class="string">&#x27;say&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">  [s]() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>, <span class="variable language_">this</span>.<span class="property">age</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">// 继承Person</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="comment">// super可以理解为父类的，super可以用来调用属性、方法、构造器</span></span><br><span class="line">    <span class="variable language_">super</span>(name, age)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getname</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Module-语法"><a href="#Module-语法" class="headerlink" title="Module 语法"></a>Module 语法</h2><p>模块化是指将一个很大的程序文件，拆分为许多个小的文件，然后将多个小文件组合起来</p>
<p>在 ES6 模块化规范诞生之前，JavaScript 社区已经尝试并提出了 AMD、CMD、CommonJS 等模块化规范。<br>但是，这些由社区提出的模块化标准，还是存在一定的差异性与局限性、并不是浏览器与服务器通用的模块化标准，例如：<br>AMD 和 CMD 适用于浏览器端的 Javascript 模块化<br>CommonJS 适用于服务器端的 Javascript 模块化<br>ES6 模块化规范是浏览器端与服务器端通用的模块化开发规范</p>
<ul>
<li>模块化的好处：<br>  ① 阻止命名冲突； ② 代码复用； ③ 高维护性</li>
<li>ES6 模块化语法：<br>  ① export 命令：用于规定模块的对外接口<br>    ② import 命令：用于输入其他模块提供的功能</li>
<li>默认导出与默认导入</li>
</ul>
<ol>
<li>默认导出的语法：<code>export default</code></li>
<li>默认导出的成员默认导入的语法：<code>import 接收名称 from &#39;模块标识符&#39;</code></li>
</ol>
<ul>
<li>按需导入与按需导出</li>
</ul>
<ol>
<li>按需导入语法：<code>export 类型</code></li>
<li>成员按需导出语法：<code>import &#123; 成员 &#125; from &#39;模块标识符&#39;</code></li>
</ol>
<h1 id="ES7"><a href="#ES7" class="headerlink" title="ES7"></a>ES7</h1><h2 id="求幂运算符"><a href="#求幂运算符" class="headerlink" title="求幂运算符"></a>求幂运算符</h2><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">3</span>, <span class="number">2</span>) === <span class="number">3</span> ** <span class="number">2</span> <span class="comment">// 9</span></span><br></pre></td></tr></table></figure></div>

<h2 id="数组的-includes-方法"><a href="#数组的-includes-方法" class="headerlink" title="数组的 includes 方法"></a>数组的 includes 方法</h2><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">;[<span class="number">1</span>, <span class="number">2</span>, <span class="title class_">NaN</span>]</span><br><span class="line">  .<span class="title function_">includes</span>(<span class="title class_">NaN</span>) <span class="comment">// true</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">2</span>, <span class="title class_">NaN</span>)].<span class="title function_">indexOf</span>(<span class="title class_">NaN</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>如果仅仅查找数据是否在数组中，建议使用 includes，如果是查找数据的索引位置，建议使用 indexOf 更好一些</p>
</blockquote>
<h1 id="ES8"><a href="#ES8" class="headerlink" title="ES8"></a>ES8</h1><h2 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h2><ul>
<li><strong>Async</strong></li>
</ul>
<blockquote>
<p>async 函数，使得异步操作变得更加方便。<br>更好的语义。<br>返回值是 Promise。</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title function_">test</span>()</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>Await</strong></li>
</ul>
<blockquote>
<p><code>await</code>命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> res1 = <span class="keyword">await</span> <span class="title function_">ajax</span>(<span class="string">&#x27;http://localhost:3000/news1&#x27;</span>)</span><br><span class="line">  <span class="keyword">var</span> res2 = <span class="keyword">await</span> <span class="title function_">ajax</span>(<span class="string">&#x27;http://localhost:3000/news2&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> res2</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;返回结果&#x27;</span>, res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;err&#x27;</span>, err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>错误处理</strong></li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> res1 = <span class="keyword">await</span> <span class="title function_">ajax</span>(<span class="string">&#x27;http://localhost:3000/news1&#x27;</span>)</span><br><span class="line">  <span class="keyword">var</span> res2 = <span class="keyword">await</span> <span class="title function_">ajax</span>(<span class="string">&#x27;http://localhost:3000/news2&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;err&#x27;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="对象方法扩展"><a href="#对象方法扩展" class="headerlink" title="对象方法扩展"></a>对象方法扩展</h2><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kerwin&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(obj))</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kerwin&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(obj))</span><br><span class="line"><span class="comment">//转Map结构</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kerwin&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj))</span><br><span class="line"><span class="comment">//复制对象可使用</span></span><br></pre></td></tr></table></figure></div>

<p>复制对象</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Kerwin&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="attr">location</span>: &#123;</span><br><span class="line">    <span class="attr">provice</span>: <span class="string">&#x27;辽宁&#x27;</span>,</span><br><span class="line">    <span class="attr">city</span>: <span class="string">&#x27;大连&#x27;</span></span><br><span class="line">  &#125;, <span class="comment">//只设置city，防止破坏province</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">city</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">location</span>.<span class="property">city</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">city</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">location</span>.<span class="property">city</span> = value</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">nameset</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = value.<span class="title function_">substring</span>(<span class="number">0</span>, <span class="number">1</span>).<span class="title function_">toUpperCase</span>() + value.<span class="title function_">substring</span>(<span class="number">1</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">nameset</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj1))</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;</span><br><span class="line"><span class="comment">//Object.assign(obj2,obj1)//无法克隆 get set方法</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(obj2, <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj1))</span><br></pre></td></tr></table></figure></div>

<h2 id="字符串填充"><a href="#字符串填充" class="headerlink" title="字符串填充"></a>字符串填充</h2><blockquote>
<p>padStart()、padEnd()方法可以使得字符串达到固定长度，有两个参数，字符串目标长度和填充内容。</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;cccccc&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">padStart</span>(<span class="number">10</span>, <span class="string">&#x27;x&#x27;</span>)) <span class="comment">//xxxxcccccc</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">padEnd</span>(<span class="number">10</span>, <span class="string">&#x27;x&#x27;</span>)) <span class="comment">//ccccccxxxx</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">padStart</span>(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>)) <span class="comment">//cccccc</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">padEnd</span>(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>)) <span class="comment">//cccccc</span></span><br></pre></td></tr></table></figure></div>

<h2 id="函数参数的末尾加逗号"><a href="#函数参数的末尾加逗号" class="headerlink" title="函数参数的末尾加逗号"></a>函数参数的末尾加逗号</h2><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>『末尾逗号』在添加新的参数、属性、元素时是有用的，你可以直接新加一行而不必给上一行再补充一个逗号，这样使版本控制工具的修改记录也更加整洁(git)</p>
</blockquote>
<h1 id="ES9"><a href="#ES9" class="headerlink" title="ES9"></a>ES9</h1><h2 id="对象的剩余参数"><a href="#对象的剩余参数" class="headerlink" title="对象的剩余参数"></a>对象的剩余参数</h2><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">location</span>: <span class="string">&#x27;xizang&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; name, ...other &#125; = obj</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name) <span class="comment">//zs</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(other) <span class="comment">//&#123;age: 18, location: &#x27;xizang&#x27;&#125;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h2><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123; ...obj1, ...obj2 &#125;)</span><br></pre></td></tr></table></figure></div>

<h2 id="正则表达式命名捕获组"><a href="#正则表达式命名捕获组" class="headerlink" title="正则表达式命名捕获组"></a>正则表达式命名捕获组</h2><p>JS 正则表达式可以返回一个匹配的对象, 一个包含匹配字符串的类数组, 比如: 以 YYYY-MM-DD 的格式解析日期，<br>这样的代码可读性很差, 并且在改变正则表达式的结构的时候很有可能就会改变匹配对象的索引</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;今天是2022-10-10&#x27;</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/([0-9]&#123;4&#125;)-([0-9]&#123;2&#125;)-([0-9]&#123;2&#125;)/g</span></span><br><span class="line"><span class="keyword">let</span> res1 = reg.<span class="title function_">exec</span>(str)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res1)</span><br></pre></td></tr></table></figure></div>

<p>ES9 允许使用命名捕获 ?<name> , 在打开捕获括号后立即命名</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;今天是2022-10-10&#x27;</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;2&#125;)-(?&lt;day&gt;[0-9]&#123;2&#125;)/g</span></span><br><span class="line"><span class="keyword">let</span> res1 = reg.<span class="title function_">exec</span>(str)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res1)</span><br></pre></td></tr></table></figure></div>

<h2 id="Promise-finally"><a href="#Promise-finally" class="headerlink" title="Promise.finally()"></a>Promise.finally()</h2><blockquote>
<p>无论是成功还是失败, 都运行同样的代码, 比如隐藏对话框, 关闭数据连接</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">1111</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//showloading</span></span><br><span class="line"><span class="title function_">ajax</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//hideloading</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;finally&#x27;</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></div>

<h2 id="异步遍历器"><a href="#异步遍历器" class="headerlink" title="异步遍历器"></a>异步遍历器</h2><p>Generator 函数返回一个同步遍历器，异步 Generator 函数的作用，是返回一个异步遍历器对象。在语法上，异步 Generator 函数就是 async 函数与 Generator 函数的结合。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">timer</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(timer)</span><br><span class="line">    &#125;, timer)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_">ajax</span>(<span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_">ajax</span>(<span class="number">2000</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_">ajax</span>(<span class="number">3000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (item <span class="keyword">of</span> <span class="title function_">gen</span>()) <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure></div>

<h1 id="ES10"><a href="#ES10" class="headerlink" title="ES10"></a>ES10</h1><h2 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries"></a>Object.fromEntries</h2><blockquote>
<p>Object.fromEntries()方法允许你轻松地将键值对列表转换为对象</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;kerwin&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;age&#x27;</span>, <span class="number">100</span>]</span><br><span class="line">]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(arr)) <span class="comment">//&#123;name: &#x27;kerwin&#x27;, age: 100&#125;</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;tiechui&#x27;</span>)</span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;age&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(m))</span><br></pre></td></tr></table></figure></div>

<p><strong>用处</strong></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;name=kerwin&amp;age=100&#x27;</span></span><br><span class="line"><span class="keyword">let</span> searchParams = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(str)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(searchParams)) <span class="comment">//&#123;name: &#x27;kerwin&#x27;, age: &#x27;100&#x27;&#125;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="trimStart-and-trimEnd"><a href="#trimStart-and-trimEnd" class="headerlink" title="trimStart() and trimEnd()"></a>trimStart() and trimEnd()</h2><blockquote>
<p>trimStart()和 trimEnd()方法在实现与 trimLeft()和 trimRight()相同。去掉首尾空格</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;   cccccc    &#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;|&#x27;</span> + str.<span class="title function_">trimStart</span>(str) + <span class="string">&#x27;|&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;|&#x27;</span> + str.<span class="title function_">trimEnd</span>(str) + <span class="string">&#x27;|&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;|&#x27;</span> + str.<span class="title function_">trimLeft</span>(str) + <span class="string">&#x27;|&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;|&#x27;</span> + str.<span class="title function_">trimRight</span>(str) + <span class="string">&#x27;|&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<h2 id="flat-与-flatMap-方法"><a href="#flat-与-flatMap-方法" class="headerlink" title="flat 与 flatMap 方法"></a>flat 与 flatMap 方法</h2><p>flat<br>该方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。<br>falt(数组的深度)<br>falt(1)相当于 flatMap</p>
<p>flatMap<br>按照一个可指定的深度递归遍历数组,并将所有元素与遍历到的子数组中的元素合并为一个新数组返回</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">    <span class="attr">list</span>: [<span class="string">&#x27;鞍山&#x27;</span>, <span class="string">&#x27;安庆&#x27;</span>, <span class="string">&#x27;安阳&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;B&#x27;</span>,</span><br><span class="line">    <span class="attr">list</span>: [<span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;保定&#x27;</span>, <span class="string">&#x27;包头&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">flatMap</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">list</span>))</span><br></pre></td></tr></table></figure></div>

<h2 id="Symbol-对象的-description-属性"><a href="#Symbol-对象的-description-属性" class="headerlink" title="Symbol 对象的 description 属性"></a>Symbol 对象的 description 属性</h2><blockquote>
<p>为 Symbol 对象添加了只读属性 description ，该对象返回包含 Symbol 描述的字符串。</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="title class_">Symbol</span>(<span class="string">&#x27;cccccc&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">description</span>) <span class="comment">//cccccc</span></span><br></pre></td></tr></table></figure></div>

<h2 id="可选的-catch"><a href="#可选的-catch" class="headerlink" title="可选的 catch"></a>可选的 catch</h2><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pro1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">//执行器函数</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;成功的结果&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">30000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> pro2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">//执行器函数</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>()</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">race</span>([pro1, pro2])</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;不关心错误结果，网络超时&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>()</span><br></pre></td></tr></table></figure></div>

<h1 id="ES11"><a href="#ES11" class="headerlink" title="ES11"></a>ES11</h1><h2 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h2><blockquote>
<p>Promise.allSettled() 方法返回一个在所有给定的 promise 都已经 fulfilled 或 rejected 后的 promise ，并带有一个对象数组，每个对象表示对应的 promise 结果。</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [<span class="title function_">ajax</span>(<span class="string">&#x27;/200接口&#x27;</span>), <span class="title function_">ajax</span>(<span class="string">&#x27;/401接口&#x27;</span>)]</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(promises).<span class="title function_">then</span>(<span class="function">(<span class="params">results</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 过滤出成功的请求</span></span><br><span class="line">  results.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">status</span> === <span class="string">&#x27;fulfilled&#x27;</span>)</span><br><span class="line">  <span class="comment">// 过滤出失败的请求</span></span><br><span class="line">  results.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">status</span> === <span class="string">&#x27;rejected&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<h2 id="module-新增"><a href="#module-新增" class="headerlink" title="module 新增"></a>module 新增</h2><ul>
<li>动态导入 import()</li>
</ul>
<blockquote>
<p>标准用法的 import 导入的模块是静态的，会使所有被导入的模块，在加载时就被编译（无法做到按需编译，降低首页加载速度）。有些场景中，你可能希望根据条件导入模块或者按需导入模块，这时你可以使用动态导入代替静态导入。</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>login<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">let</span> role1 = <span class="string">&quot;管理员&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">let</span> role2 = <span class="string">&quot;普通用户&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">function</span> <span class="title function_">login</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">return</span> <span class="string">&quot;普通用户&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">role</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">if</span>(role===role1)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="keyword">let</span> res1 = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&quot;./1.js&quot;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="variable language_">console</span>.<span class="title function_">log</span>(res1.<span class="property">default</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;<span class="keyword">else</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="keyword">let</span> res2 = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&quot;./2.js&quot;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="variable language_">console</span>.<span class="title function_">log</span>(res2.<span class="property">default</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">let</span> obtn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;button&quot;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        obtn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">let</span> role = <span class="title function_">login</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">render</span>(role)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ul>
<li>import.meta</li>
</ul>
<p>import.meta 会返回一个对象，有一个 url 属性，返回当前模块的 url 路径，只能在模块内部使用。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">;<span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"><span class="keyword">import</span> obj <span class="keyword">from</span> <span class="string">&#x27;./1.js&#x27;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="comment">//1.js</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">import</span>.<span class="property">meta</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>export * as obj from ‘module’</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;111111&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">test1</span>(<span class="params"></span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;22222&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">test2</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">as</span> obj1 <span class="keyword">from</span> <span class="string">&#x27;./1.js&#x27;</span></span><br><span class="line"><span class="comment">//html</span></span><br><span class="line"> &lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">        <span class="keyword">import</span> * <span class="keyword">as</span> obj <span class="keyword">from</span> <span class="string">&#x27;./2.js&#x27;</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<h2 id="字符串的-matchAll-方法"><a href="#字符串的-matchAll-方法" class="headerlink" title="字符串的 matchAll 方法"></a>字符串的 matchAll 方法</h2><blockquote>
<p>matchAll() 方法返回一个包含所有匹配正则表达式的结果的迭代器。可以使用 for…of 遍历，或者使用 展开运算符(…) 或者 Array.from 转换为数组.</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;1111&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;2222&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;3333&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;4444&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/&lt;li&gt;(.*)&lt;\/li&gt;/g</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(reg))</span><br><span class="line"><span class="comment">//&#x27;&lt;li&gt;1111&lt;/li&gt;&#x27;, &#x27;&lt;li&gt;2222&lt;/li&gt;&#x27;, &#x27;&lt;li&gt;3333&lt;/li&gt;&#x27;, &#x27;&lt;li&gt;4444&lt;/li&gt;&#x27;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不用matchAll()</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;1111&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;2222&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;3333&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;4444&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/&lt;li&gt;(.*)&lt;\/li&gt;/g</span></span><br><span class="line"><span class="keyword">let</span> match = <span class="literal">null</span></span><br><span class="line"><span class="keyword">while</span> ((match = reg.<span class="title function_">exec</span>(str))) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(match[<span class="number">0</span>])</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(match[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用matchAll()</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;1111&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;2222&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;3333&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;4444&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/&lt;li&gt;(.*)&lt;\/li&gt;/g</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> str.<span class="title function_">matchAll</span>(reg)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h2><blockquote>
<p>JavaScript 能够准确表示的整数范围在-2^53 到 2^53 之间（不含两个端点），超过这个范围，无法精确表示这个值，这使得 JavaScript 不适合进行科学和金融方面的精确计算。</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">9007199254740992</span> <span class="comment">//9007199254740992</span></span><br><span class="line"><span class="number">9007199254740993</span> <span class="comment">//9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>) === <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<p>为了与 Number 类型区别，BigInt 类型的数据必须添加后缀<code>n</code>。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1234</span> <span class="comment">// 普通整数</span></span><br><span class="line"><span class="number">1234n</span> <span class="comment">// BigInt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BigInt 的运算</span></span><br><span class="line"><span class="number">1n</span> + <span class="number">2n</span> <span class="comment">// 3n</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>json-bigint 这个库使用了 BigInt,可通过<code>npm i json-bigint </code>下载</p>
</blockquote>
<h2 id="globalThis"><a href="#globalThis" class="headerlink" title="globalThis"></a>globalThis</h2><blockquote>
<p>globalThis 提供了一个标准的方式来获取不同环境下的全局 this 对象（也就是全局对象自身）。不像 window 或者 self 这些属性，它确保可以在有无窗口的各种环境下正常工作。所以，你可以安心的使用 globalThis，不必担心它的运行环境。为便于记忆，你只需要记住，全局作用域中的 this 就是 globalThis。</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//es6-shim</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getGlobal = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the only reliable means to get the global object is</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Function(&#x27;return this&#x27;)()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// However, this causes CSP violations in Chrome apps.</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">&#x27;undefined&#x27;</span>) &#123; <span class="keyword">return</span> self; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">window</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123; <span class="keyword">return</span> <span class="variable language_">window</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">global</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123; <span class="keyword">return</span> <span class="variable language_">global</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;unable to locate global object&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> globals = <span class="title function_">getGlobal</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!globals.<span class="property">Reflect</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="title function_">defineProperty</span>(globals, ‘<span class="title class_">Reflect</span>’, &#123;&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以前</span></span><br><span class="line"><span class="keyword">var</span> getGlobal = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">window</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">window</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">global</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">global</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;unable to locate global object&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> globals = <span class="title function_">getGlobal</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (globals.<span class="property">document</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;进行dom操作相关&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;不能进行dom操作&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在</span></span><br><span class="line"><span class="keyword">if</span> (globalThis.<span class="property">document</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;进行dom操作相关&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;不能进行dom操作&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="空值合并运算符"><a href="#空值合并运算符" class="headerlink" title="空值合并运算符"></a>空值合并运算符</h2><blockquote>
<p><strong>空值合并运算符（_??_）</strong>是一个逻辑运算符。当左侧操作数为 null 或 undefined 时，其返回右侧的操作数。否则返回左侧的操作数。</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kerwin&#x27;</span>,</span><br><span class="line">  <span class="attr">introduction</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">introduction</span> || <span class="string">&#x27;这个人很懒&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">introduction</span> ?? <span class="string">&#x27;这个人很懒&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>??和 || 的区别是什么呢?</strong></p>
<p>他们两个最大的区别就是 ’ ‘和 0，??的左侧 为 ’ ‘或者为 0 的时候，依然会返回左侧的值；</p>
<p>|| 会对左侧的数据进行 boolean 类型转换，所以’ ‘和 0 会被转换成 false,返回右侧的值</p>
<h2 id="可选链操作符"><a href="#可选链操作符" class="headerlink" title="可选链操作符"></a>可选链操作符</h2><blockquote>
<p>可选链前面的值如果是 null 或 undefined，则不再执行后面的，之前返回可选链前面的值</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kerwin&#x27;</span>,</span><br><span class="line">  <span class="attr">introduction</span>: <span class="number">0</span></span><br><span class="line">  <span class="comment">// location:&#123;</span></span><br><span class="line">  <span class="comment">//     city:&quot;dalian&quot;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj &amp;&amp; obj.<span class="property">location</span> &amp;&amp; obj.<span class="property">location</span>.<span class="property">city</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj?.<span class="property">location</span>?.<span class="property">city</span>)</span><br></pre></td></tr></table></figure></div>

<h1 id="ES12"><a href="#ES12" class="headerlink" title="ES12"></a>ES12</h1><h2 id="逻辑赋值操作符"><a href="#逻辑赋值操作符" class="headerlink" title="逻辑赋值操作符"></a>逻辑赋值操作符</h2><p>逻辑赋值操作符 ??&#x3D;、&amp;&amp;&#x3D;、 ||&#x3D;</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span></span><br><span class="line"><span class="comment">//a &amp;&amp;= b //false</span></span><br><span class="line">a ||= b <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;kerwin&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">introduction</span> = obj.<span class="property">introduction</span> ?? <span class="string">&#x27;很懒&#x27;</span></span><br><span class="line">obj.<span class="property">introduction</span> ??= <span class="string">&#x27;很懒&#x27;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="数字分隔符"><a href="#数字分隔符" class="headerlink" title="数字分隔符"></a>数字分隔符</h2><p>这个新特性是为了方便程序员看代码而出现的，如果数字比较大，那么看起来就不是那么一目了然</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num= <span class="number">123456789</span>；</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>分隔符不仅可以分割十进制，也可以分割二净值或者十六净值的数据，非常好用。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> number = <span class="number">1_000_000_000_000</span></span><br><span class="line"><span class="keyword">const</span> binary = <span class="number">0b1010_0101_1111_1101</span></span><br><span class="line"><span class="keyword">const</span> hex = <span class="number">0xa1_b2_c3</span></span><br></pre></td></tr></table></figure></div>

<h2 id="replaceAll"><a href="#replaceAll" class="headerlink" title="replaceAll"></a>replaceAll</h2><blockquote>
<p>所有匹配都会被替代项替换。模式可以是字符串或正则表达式，而替换项可以是字符串或针对每次匹配执行的函数。并返回一个全新的字符串</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str =</span><br><span class="line">  <span class="string">&quot;I wish to wish the wish you wish to wish, but if you wish the wish the witch wishes, I won&#x27;t wish the wish you wish to wish. &quot;</span></span><br><span class="line"><span class="keyword">const</span> newStr = str.<span class="title function_">replaceAll</span>(<span class="string">&#x27;wish&#x27;</span>, <span class="string">&#x27;kerwin&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newStr)</span><br></pre></td></tr></table></figure></div>

<h2 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h2><p>只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</p>
<blockquote>
<p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是<code>Promise.any()</code>不会因为某个 Promise 变成<code>rejected</code>状态而结束，必须等到所有参数 Promise 变成<code>rejected</code>状态才会结束。</p>
</blockquote>
<h2 id="WeakRef"><a href="#WeakRef" class="headerlink" title="WeakRef"></a>WeakRef</h2><p><code>weakset</code>和<code>weakmap</code>:解决 set 内存泄露</p>
<ol>
<li><p>只能存复杂类型</p>
</li>
<li><p>不存在引用计数+1</p>
</li>
<li><p>size,for 不能使用</p>
</li>
</ol>
<p><code>weakRef</code>:</p>
<blockquote>
<p>在一般情况下，对象的引用是强引用的，这意味着只要持有对象的引用，它就不会被垃圾回收。只有当该对象没有任何的强引用时，垃圾回收才会销毁该对象并且回收该对象所占的内存空间。</p>
<p>而 <code>WeakRef</code> 允许您保留对另一个对象的弱引用，而不会阻止被弱引用对象被垃圾回收。</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> wr = <span class="keyword">new</span> <span class="title class_">WeakRef</span>(target)</span><br></pre></td></tr></table></figure></div>

<p>WeakRef 实例对象有一个<code>deref()</code>方法，如果原始对象存在，该方法返回原始对象；如果原始对象已经被垃圾回收机制清除，该方法返回<code>undefined</code>。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> wr = <span class="keyword">new</span> <span class="title class_">WeakRef</span>(target)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = wr.<span class="title function_">deref</span>()</span><br><span class="line"><span class="keyword">if</span> (obj) &#123;</span><br><span class="line">  <span class="comment">// target 未被垃圾回收机制清除</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> like = <span class="keyword">new</span> <span class="title class_">WeakRef</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;like&#x27;</span>))</span><br><span class="line"><span class="keyword">let</span> mymap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line">mymap.<span class="title function_">set</span>(like.<span class="title function_">deref</span>(), &#123;</span><br><span class="line">  <span class="attr">click</span>: <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line">like.<span class="title function_">deref</span>().<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> times = mymap.<span class="title function_">get</span>(like.<span class="title function_">deref</span>())</span><br><span class="line">  times.<span class="property">click</span>++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(like.<span class="title function_">deref</span>())</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure></div>

<h2 id="FinalizationRegistry"><a href="#FinalizationRegistry" class="headerlink" title="FinalizationRegistry"></a>FinalizationRegistry</h2><blockquote>
<p>清理器注册表功能 FinalizationRegistry，用来指定目标对象被垃圾回收机制清除以后，所要执行的回调函数。</p>
</blockquote>
<p>首先，新建一个注册表实例。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> registry = <span class="keyword">new</span> <span class="title class_">FinalizationRegistry</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">registry.<span class="title function_">register</span>(obj, <span class="string">&#x27;some value&#x27;</span>)</span><br><span class="line">registry.<span class="title function_">unregister</span>(obj)</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> like = <span class="keyword">new</span> <span class="title class_">WeakRef</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;like&#x27;</span>))</span><br><span class="line"><span class="keyword">let</span> mymap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line">mymap.<span class="title function_">set</span>(like.<span class="title function_">deref</span>(), &#123;</span><br><span class="line">  <span class="attr">click</span>: <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line">like.<span class="title function_">deref</span>().<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> times = mymap.<span class="title function_">get</span>(like.<span class="title function_">deref</span>())</span><br><span class="line">  times.<span class="property">click</span>++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// registry.register(document.getElementById(&quot;like&quot;), mymap.get(like.deref()));</span></span><br><span class="line">  registry.<span class="title function_">register</span>(like.<span class="title function_">deref</span>(), mymap.<span class="title function_">get</span>(like.<span class="title function_">deref</span>()))</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(like.<span class="title function_">deref</span>())</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> registry = <span class="keyword">new</span> <span class="title class_">FinalizationRegistry</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;被销毁了&#x27;</span>, data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<h1 id="ES13"><a href="#ES13" class="headerlink" title="ES13"></a>ES13</h1><h2 id="私有属性和方法"><a href="#私有属性和方法" class="headerlink" title="私有属性和方法"></a>私有属性和方法</h2><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cache</span> &#123;</span><br><span class="line">  #obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#obj[key] = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cache = <span class="keyword">new</span> <span class="title class_">Cache</span>()</span><br><span class="line">cache.<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;kerwin&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<h2 id="静态成员的私有属性和方法"><a href="#静态成员的私有属性和方法" class="headerlink" title="静态成员的私有属性和方法"></a>静态成员的私有属性和方法</h2><blockquote>
<p>我们还可以给类定义静态成员和静态私有函数。类的静态方法可以使用<code>this</code>关键字访问其他的私有或者公有静态成员，</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cache</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> #count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getCount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#count</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  #obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#obj[key] = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cache = <span class="keyword">new</span> <span class="title class_">Cache</span>()</span><br><span class="line">cache.<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;kerwin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Cache</span>.<span class="title function_">getCount</span>())</span><br></pre></td></tr></table></figure></div>

<h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><blockquote>
<p>ES13 允许在类中通过<code>static</code>关键字定义一系列静态代码块，这些代码块只会在类被创造的时候<strong>执行一次</strong>。这其实有点像一些其他的如 C#和 Java 等面向对象的编程语言的静态构造函数的用法。</p>
</blockquote>
<p>一个类可以定义任意多的静态代码块，这些代码块会和穿插在它们之间的静态成员变量一起按照定义的顺序在类初始化的时候执行一次。我们还可以使用<code>super</code>关键字来访问父类的属性。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cache</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> obj = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">obj</span>.<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;cccccc&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">obj</span>.<span class="title function_">set</span>(<span class="string">&#x27;age&#x27;</span>, <span class="number">100</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">obj</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Cache</span>.<span class="property">obj</span>)</span><br></pre></td></tr></table></figure></div>

<h2 id="使用-in-来判断某个对象是否拥有某个私有属性"><a href="#使用-in-来判断某个对象是否拥有某个私有属性" class="headerlink" title="使用 in 来判断某个对象是否拥有某个私有属性"></a>使用 in 来判断某个对象是否拥有某个私有属性</h2><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cache</span> &#123;</span><br><span class="line">  #obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#obj[key] = value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">hasObj</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> #obj <span class="keyword">in</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cache = <span class="keyword">new</span> <span class="title class_">Cache</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cache.<span class="title function_">hasObj</span>())</span><br></pre></td></tr></table></figure></div>

<h2 id="支持在最外层写-await"><a href="#支持在最外层写-await" class="headerlink" title="支持在最外层写 await"></a>支持在最外层写 await</h2><blockquote>
<p>顶层<code>await</code>只能用在 ES6 模块，不能用在 CommonJS 模块。这是因为 CommonJS 模块的<code>require()</code>是同步加载，如果有顶层<code>await</code>，就没法处理加载了。</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&quot;data-1111&quot;</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = <span class="keyword">await</span> <span class="title function_">ajax</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="at-函数来索引元素"><a href="#at-函数来索引元素" class="headerlink" title="at 函数来索引元素"></a>at 函数来索引元素</h2><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;tiechui&#x27;</span>, <span class="string">&#x27;gangdan&#x27;</span>, <span class="string">&#x27;xiaoming&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">1</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[arr.<span class="property">length</span> - <span class="number">1</span>]) <span class="comment">//变丑了</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[arr.<span class="property">length</span> - <span class="number">2</span>]) <span class="comment">//变丑了</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">at</span>(<span class="number">1</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">at</span>(-<span class="number">1</span>)) <span class="comment">//等价于arr[arr.length-1]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">at</span>(-<span class="number">2</span>)) <span class="comment">//等价于arr[arr.length-2]</span></span><br></pre></td></tr></table></figure></div>

<h2 id="正则匹配的开始和结束索引"><a href="#正则匹配的开始和结束索引" class="headerlink" title="正则匹配的开始和结束索引"></a>正则匹配的开始和结束索引</h2><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;今天是2022-11-10&#x27;</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;2&#125;)-(?&lt;day&gt;[0-9]&#123;2&#125;)/</span>d</span><br><span class="line"></span><br><span class="line"><span class="comment">//exec</span></span><br><span class="line"><span class="keyword">let</span> res = reg.<span class="title function_">exec</span>(str)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br></pre></td></tr></table></figure></div>

<h2 id="findLast-和-findLastIndex-函数"><a href="#findLast-和-findLastIndex-函数" class="headerlink" title="findLast()和 findLastIndex()函数"></a>findLast()和 findLastIndex()函数</h2><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// let res = arr.find(function(value)&#123;</span></span><br><span class="line"><span class="comment">//   return value % 2 === 0</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// let res = arr.findIndex(function(value)&#123;</span></span><br><span class="line"><span class="comment">//   return value % 2 === 0</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// let res = arr.findLast(function(value)&#123;</span></span><br><span class="line"><span class="comment">//   return value % 2 === 0</span></span><br><span class="line"><span class="comment">// &#125;)//从后往前</span></span><br><span class="line"><span class="keyword">let</span> res = arr.<span class="title function_">findLastIndex</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> value % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">&#125;) <span class="comment">//从后往前</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br></pre></td></tr></table></figure></div>

<h2 id="Error-对象的-Cause-属性"><a href="#Error-对象的-Cause-属性" class="headerlink" title="Error 对象的 Cause 属性"></a>Error 对象的 Cause 属性</h2><blockquote>
<p>Error 对象多了一个<code>cause</code>属性来指明错误出现的原因。这个属性可以帮助我们为错误添加更多的上下文信息，从而帮助使用者们更好地定位错误。</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(kerwin)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;New error 1111111&#x27;</span>, &#123; <span class="attr">cause</span>: <span class="string">&#x27;这是因为,,,,,,,,,&#x27;</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">getData</span>()</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">cause</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
  </entry>
  <entry>
    <title>Typescript</title>
    <url>/2023/03/04/Typescript/</url>
    <content><![CDATA[<p>Typescript 不是一门全新的语言, 它相当于是 JavaScript 的超集, 对 js 进行了一些规范和补充.<br>js 只会在运行时去做数据类型检查, 而 ts 作为静态类型语言, 其数据类型是在编译期间确定的, 编写代码的时候, 要明确变量的数据类型, 使用 ts 后, 就不会出现因为数据类型错误导致的代码运行异常</p>
<h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">number</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum1</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum1</span>(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="built_in">any</span></span><br><span class="line">c = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">d</span>: <span class="built_in">unknown</span></span><br><span class="line">d = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">s</span>: <span class="built_in">string</span></span><br><span class="line">s = c</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> d == <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">  s = d</span><br><span class="line">&#125;</span><br><span class="line">s = d <span class="keyword">as</span> <span class="built_in">string</span></span><br><span class="line">s = &lt;<span class="built_in">string</span>&gt;d</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;报错了&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">e</span>: &#123; <span class="attr">name</span>: <span class="built_in">string</span>; age?: <span class="built_in">number</span> &#125;</span><br><span class="line">e = &#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span> &#125;</span><br><span class="line">e = &#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">f</span>: &#123; <span class="attr">name</span>: <span class="built_in">string</span>; [<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">any</span> &#125;</span><br><span class="line">f = &#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">g</span>: <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line">g = <span class="keyword">function</span> (<span class="params">n1, n2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">h</span>: <span class="built_in">number</span>[]</span><br><span class="line">h = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">i</span>: <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">l</span>: [<span class="built_in">string</span>, <span class="built_in">string</span>]</span><br><span class="line">l = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Gender</span> &#123;</span><br><span class="line">  <span class="title class_">Male</span> = <span class="number">0</span>,</span><br><span class="line">  <span class="title class_">Female</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">j</span>: &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">gender</span>: <span class="title class_">Gender</span> &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">k</span>: &#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125; &amp; &#123; <span class="attr">age</span>: <span class="built_in">number</span> &#125;</span><br><span class="line">k = &#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="keyword">type</span> num = <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span> | <span class="number">6</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">m</span>: num</span><br><span class="line">m = <span class="number">1</span></span><br><span class="line">m = <span class="number">2</span></span><br><span class="line">m = <span class="number">3</span></span><br></pre></td></tr></table></figure></div>

<h3 id="配置文件—tsconfig-json"><a href="#配置文件—tsconfig-json" class="headerlink" title="配置文件—tsconfig.json"></a>配置文件—tsconfig.json</h3><p>（*_ 任意文件夹 ，_ 任意文件）</p>
<ul>
<li>include: 包含的文件（匹配）</li>
<li>exclude: 不包含的文件</li>
<li>files:包含的文件（文件名）</li>
</ul>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/**/*&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;exclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/hello/*&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;hello.ts&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<p>compilerOptions</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">//指定编译为js的版本，可选值：&quot;ES3&quot;, &quot;ES5&quot;, &quot;ES6&quot;, &quot;ES2015&quot;, &quot;ES2016&quot;, &quot;ES2017&quot;, &quot;ES2018&quot;,</span></span><br><span class="line">    <span class="comment">//&quot;ES2019&quot;, &quot;ES2020&quot;, &quot;ES2021&quot;, &quot;ES2022&quot;, &quot;ES2023&quot;, &quot;ESNext&quot;</span></span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;ES2015&quot;</span>,</span><br><span class="line">    <span class="comment">//指定使用模块化规范，可选值：&quot;CommonJS&quot;, &quot;AMD&quot;, &quot;System&quot;, &quot;UMD&quot;, &quot;ES6&quot;, &quot;ES2015&quot;,</span></span><br><span class="line">    <span class="comment">//&quot;ES2020&quot;, &quot;ESNext&quot;, &quot;None&quot;, &quot;ES2022&quot;, &quot;Node16&quot;, &quot;NodeNext&quot;</span></span><br><span class="line">    <span class="string">&quot;module&quot;</span>: <span class="string">&quot;ES2015&quot;</span>,</span><br><span class="line">     <span class="comment">// 指定项目使用的库，一般不动</span></span><br><span class="line">    <span class="comment">// &quot;lib&quot;:[],</span></span><br><span class="line">    <span class="comment">// 指定编译后文件所在的目录</span></span><br><span class="line">    <span class="string">&quot;outDir&quot;</span>:<span class="string">&quot;./dist&quot;</span>,</span><br><span class="line">    <span class="comment">// 所有全局作用于的代码都会合并到同一个文件中</span></span><br><span class="line">    <span class="comment">// &quot;outFile&quot;: &quot;&quot;,</span></span><br><span class="line">    <span class="comment">// 是否对js文件进行编译默认false</span></span><br><span class="line">    <span class="string">&quot;allowJs&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 是否检查js是否符合语法规范默认false</span></span><br><span class="line">    <span class="string">&quot;checkJs&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 是否移除注释</span></span><br><span class="line">    <span class="string">&quot;removeComments&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 是否不生成编译后的文件</span></span><br><span class="line">    <span class="string">&quot;noEmit&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 当有错误时不生成编译后的文件</span></span><br><span class="line">    <span class="string">&quot;noEmitOnError&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 所有严格检查的总开关</span></span><br><span class="line">    <span class="string">&quot;strict&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 是否使用js严格模式默认false</span></span><br><span class="line">    <span class="string">&quot;alwaysStrict&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 不允许隐式的any类型</span></span><br><span class="line">    <span class="string">&quot;noImplicitAny&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 不允许不明确的this</span></span><br><span class="line">    <span class="string">&quot;noImplicitThis&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 严格模式检查空值</span></span><br><span class="line">    <span class="string">&quot;strictNullChecks&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></div>

<h3 id="webpack-打包-ts-代码"><a href="#webpack-打包-ts-代码" class="headerlink" title="webpack 打包 ts 代码"></a>webpack 打包 ts 代码</h3><p>一</p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure></div>

<p>二</p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">npm i -D webpack webpack-cli typescript ts-loader</span><br></pre></td></tr></table></figure></div>

<p>三<br>创建 webpack.config.js</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入一个包</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="comment">// webpack所有配置信息都应写在module.exports</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 指定入口文件</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.ts&#x27;</span>, <span class="comment">// 指定打包文件所在目录</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">// 指定打包文件的目录</span></span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>), <span class="comment">// 打包后文件的文件名</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">  &#125;, <span class="comment">// 指定webpack打包要使用的模块</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="comment">// 指定要加载的规则</span></span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// test指定的是规则生效的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>, <span class="comment">// 要使用的loader</span></span><br><span class="line">        <span class="attr">use</span>: <span class="string">&#x27;ts-loader&#x27;</span>, <span class="comment">// 要排除的文件</span></span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/node-modules/</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>四<br>创建 tsconfig.json</p>
<div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;module&quot;</span>: <span class="string">&quot;ES2015&quot;</span>,</span><br><span class="line">        <span class="string">&quot;target&quot;</span>: <span class="string">&quot;ES2015&quot;</span>,</span><br><span class="line">        <span class="string">&quot;strict&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>五<br>在 package.json 中·添加“buid”:”webpack”</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Ts/ts_5.png"
                     
                ></p>
<!-- ![0a2d9e5443696b4e41b75d11afa5c3c7.png](en-resource://database/885:1) -->

<p>六<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Ts/ts_6.png"
                     
                ><br><code>const HTMLWebpackPlugin = require(&#39;html-webpack-plugin&#39;)</code></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置webpack插件</span></span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">HTMLWebpackPlugin</span>(&#123;</span><br><span class="line">    <span class="comment">//title:&quot;标题&quot;</span></span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div>

<p>七<br>安装 webpack-dev-server<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Ts/ts_7_1.png"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Ts/ts_7_2.png"
                     
                ><br>open 后面可不加<br>八<br>安装 clean-webpack-plugin<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Ts/ts_8_1.png"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Ts/ts_8_2.png"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Ts/ts_8_3.png"
                     
                ></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用来设置引入模块</span></span><br><span class="line"><span class="comment">//js,ts文件可作为模块进行打包</span></span><br><span class="line"><span class="attr">resolve</span>: &#123;</span><br><span class="line">  <span class="attr">extensions</span>: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.ts&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>九<br>安装 babel<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Ts/ts_9_1.png"
                     
                ><br>在 webpack.config.js 中</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">use</span>: [</span><br><span class="line">          <span class="comment">// 配置babel</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// 指定加载器</span></span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">            <span class="comment">// 设置babel</span></span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="comment">// 设置加载环境</span></span><br><span class="line">              <span class="attr">presets</span>: [</span><br><span class="line">                [</span><br><span class="line">                  <span class="comment">// 指定环境的插件</span></span><br><span class="line">                  <span class="string">&#x27;@babel/preset-env&#x27;</span>,</span><br><span class="line">                  <span class="comment">// 配置信息</span></span><br><span class="line">                  &#123;</span><br><span class="line">                    <span class="comment">// 要兼容的目标浏览器</span></span><br><span class="line">                    <span class="attr">targets</span>: &#123;</span><br><span class="line">                      <span class="attr">chrome</span>: <span class="string">&#x27;58&#x27;</span>,</span><br><span class="line">                      <span class="attr">ie</span>: <span class="string">&#x27;11&#x27;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="comment">// 指定corejs的版本</span></span><br><span class="line">                    <span class="attr">corejs</span>: <span class="string">&#x27;3&#x27;</span>,</span><br><span class="line">                    <span class="comment">// 使用corejs的方式“usage” 表示加载</span></span><br><span class="line">                    <span class="attr">useBuiltIns</span>: <span class="string">&#x27;usage&#x27;</span></span><br><span class="line">                  &#125;</span><br><span class="line">                ]</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&#x27;ts-loader&#x27;</span></span><br><span class="line">        ],</span><br></pre></td></tr></table></figure></div>

<p>打包不使用箭头函数<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/Ts/ts_9_2.png"
                     
                ></p>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>简单类</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line">  <span class="comment">// 实例属性：直接定义的属性，需要通过实例对象访问</span></span><br><span class="line">  <span class="attr">name</span>: string = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="comment">//静态属性（类属性）：使用static开头的属性，直接通过类访问</span></span><br><span class="line">  <span class="keyword">static</span> <span class="attr">age</span>: number</span><br><span class="line">  <span class="comment">// readonly开头的属性表示一个只读的属性无法修改</span></span><br><span class="line">  <span class="comment">// 定义方法</span></span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> per = <span class="keyword">new</span> <span class="title function_">person</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>)</span><br></pre></td></tr></table></figure></div>

<p>构造函数</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: string</span><br><span class="line">  <span class="attr">age</span>: number <span class="comment">//构造函数会在对象创建时调用</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: string, age: number</span>) &#123;</span><br><span class="line">    <span class="comment">// 在实例方法中，this就表示当前的实例</span></span><br><span class="line">    <span class="comment">// 在构造函数中当前对象就是新建的那个是对象</span></span><br><span class="line">    <span class="comment">// 可通过this向新建的对象中添加属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;小黑&#x27;</span>, <span class="number">10</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog)</span><br></pre></td></tr></table></figure></div>

<p>继承</p>
<div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">say</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;~~&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Dog继承Aniaml</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>在跑`</span>)</span><br><span class="line">  &#125; <span class="comment">// 方法的重写</span></span><br><span class="line">  <span class="title function_">say</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;wangwang&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;小黑&#x27;</span>, <span class="number">12</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog)</span><br><span class="line">dog.<span class="title function_">say</span>()</span><br><span class="line">dog.<span class="title function_">run</span>()</span><br></pre></td></tr></table></figure></div>

<p>super</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: string</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: string</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">say</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;~~&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="attr">age</span>: number</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: string, age: number</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果在子类中写了构造函数则必须通过super对父类构造函数进行调用</span></span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">say</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 在类的方法中使用super就表示当前类的父亲</span></span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">say</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;小黑&#x27;</span>, <span class="number">12</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog)</span><br><span class="line">dog.<span class="title function_">say</span>()</span><br></pre></td></tr></table></figure></div>

<p>抽象类</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 抽象类：以abstract开头的是抽象类</span></span><br><span class="line">  <span class="comment">// 抽象类和其他类区别不大只是不能用来创建</span></span><br><span class="line">  <span class="comment">// 抽象类就是专门用来继承的</span></span><br><span class="line">abstract <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">  <span class="attr">name</span>:string;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name:string </span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span>=name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 抽象方法</span></span><br><span class="line">  <span class="comment">// 使用abstract定义的方法，没有方法体</span></span><br><span class="line">  <span class="comment">// 抽象方法只能定义在抽象类中，子类必须对抽象方法重写</span></span><br><span class="line">   abstract <span class="title function_">say</span>():<span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="title function_">say</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;wang&quot;</span>);</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dog=<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;小黑&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog);</span><br><span class="line">dog.<span class="title function_">say</span>()</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>接口</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">type myType = &#123;</span><br><span class="line">  <span class="attr">name</span>: string,</span><br><span class="line">  <span class="attr">age</span>: number</span><br><span class="line">&#125; <span class="comment">// 接口用来定义一个类，用来定义一个类中应该包含那些属性和方法 // 接口也可以当成类型声明去使用</span></span><br><span class="line">interface myInterface &#123;</span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">  <span class="attr">age</span>: number;</span><br><span class="line">&#125;</span><br><span class="line">interface myInterface &#123;</span><br><span class="line">  <span class="attr">gender</span>: string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">obj</span>: myInterface = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">11</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125; <span class="comment">// 接口可以在定义类的时候去限制类的结构 // 接口中的所有属性都不能有实际值 // 接口只定义对象的结构，而不考虑实际值 // 接口中所有的方法都是抽象方法</span></span><br><span class="line">interface myInter &#123;</span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">  <span class="title function_">say</span>(): <span class="keyword">void</span>;</span><br><span class="line">&#125; <span class="comment">// 定义时 可使用类去实现一个接口 // 实现接口就是满足接口的要求</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> implements myInter &#123;</span><br><span class="line">  <span class="attr">name</span>: string</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: string</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">say</span>(): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;你好&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>属性的封装</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">;(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 表示人的类</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// public  修饰的属性可以再任意位置修改</span></span><br><span class="line">    <span class="comment">// private 私有属性，只能在类的内部进行访问</span></span><br><span class="line">    <span class="comment">// protected 受包含的属性只能在当前类和当前类的子类中访问</span></span><br><span class="line">    <span class="comment">// 添加方法get和set</span></span><br><span class="line">    <span class="attr">name</span>: string</span><br><span class="line">    <span class="attr">age</span>: number</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: string, age: number</span>) &#123;</span><br><span class="line">      ;(<span class="variable language_">this</span>.<span class="property">name</span> = name), (<span class="variable language_">this</span>.<span class="property">age</span> = age)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="comment">// 和上面等价语法糖 // class Person&#123; //   constructor(private name: string, private age:number)&#123; //     this.name=name, //     this.age=age //   &#125; // &#125;</span></span><br><span class="line">  <span class="keyword">const</span> per = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;zs&#x27;</span>, <span class="number">12</span>) <span class="comment">//  现在属性是在对象中设置的，属性可以任意修改，会导致数据变得不安全</span></span><br><span class="line">  per.<span class="property">name</span> = <span class="string">&#x27;ls&#x27;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(per)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></div>

<p>泛型</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">;(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 在定义函数或者类时，遇到不明确类型就可以使用泛型</span></span><br><span class="line">  <span class="keyword">function</span> fn&lt;T&gt;(<span class="attr">a</span>: T): T &#123;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 可以直接调用具有泛型的类</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="title function_">fn</span>(<span class="number">10</span>) <span class="comment">//不指定泛型Ts可自行推断类型</span></span><br><span class="line">  <span class="keyword">let</span> result1 = fn &lt; string &gt; <span class="string">&#x27;hello&#x27;</span> <span class="comment">//指定泛型</span></span><br><span class="line">  <span class="keyword">function</span> fn2&lt;T, K&gt;(<span class="attr">a</span>: T, <span class="attr">b</span>: K): T &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  &#125;</span><br><span class="line">  fn2 &lt; number, string &gt; (<span class="number">123</span>, <span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></div>
]]></content>
  </entry>
  <entry>
    <title>前端八股文</title>
    <url>/2023/03/18/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1%E6%96%87/</url>
    <content><![CDATA[<h2 id="HTTP-和-HTTPS"><a href="#HTTP-和-HTTPS" class="headerlink" title="HTTP 和 HTTPS"></a>HTTP 和 HTTPS</h2><h4 id="http-和-https-的基本概念"><a href="#http-和-https-的基本概念" class="headerlink" title="http 和 https 的基本概念"></a><strong>http 和 https 的基本概念</strong></h4><p>http: 是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。<br>https:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。</p>
<h4 id="http-和-https-的区别及优缺点？"><a href="#http-和-https-的区别及优缺点？" class="headerlink" title="http 和 https 的区别及优缺点？"></a><strong>http 和 https 的区别及优缺点？</strong></h4><ul>
<li>http 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议安全，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性(当然这种安全性并非绝对的，对于更深入的 Web 安全问题，此处暂且不表)。</li>
<li>http 协议的默认端口为 80，https 的默认端口为 443。</li>
<li>http 的连接很简单，是无状态的。https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。</li>
<li>https 缓存不如 http 高效，会增加数据开销。</li>
<li>Https 协议需要 ca 证书，费用较高，功能越强大的证书费用越高。</li>
<li>SSL 证书需要绑定 IP，不能再同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。</li>
</ul>
<h4 id="https-协议的工作原理"><a href="#https-协议的工作原理" class="headerlink" title="https 协议的工作原理"></a><strong>https 协议的工作原理</strong></h4><p>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：</p>
<ol>
<li>客户端使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。</li>
<li>web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），传输给客户端。</li>
<li>客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。</li>
<li>客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。</li>
<li>web 服务器通过自己的私钥解密出会话密钥。</li>
<li>web 服务器通过会话密钥加密与客户端之间的通信。</li>
</ol>
<h4 id="TCP-三次握"><a href="#TCP-三次握" class="headerlink" title="TCP 三次握"></a><strong>TCP 三次握</strong></h4><ol>
<li>第一次握手：建立连接时，客户端发送 syn 包（syn&#x3D;j）到服务器，并进入 SYN_SENT 状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</li>
<li>第二次握手：服务器收到 syn 包并确认客户的 SYN（ack&#x3D;j+1），同时也发送一个自己的 SYN 包（syn&#x3D;k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；</li>
<li>第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK(ack&#x3D;k+1），此包发送完毕，客户端和服务器进入 ESTABLISHED（TCP 连接成功）状态，完成三次握手。</li>
</ol>
<p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。</p>
<h4 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a><strong>TCP 四次挥手</strong></h4><ol>
<li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN&#x3D;1，其序列号为 seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加 1），此时，客户端进入 FIN-WAIT-1（终止等待 1）状态。 TCP 规定，FIN 报文段即使不携带数据，也要消耗一个序号。</li>
</ol>
<p>2）服务器收到连接释放报文，发出确认报文，ACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号 seq&#x3D;v，此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。</p>
<p>3）客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待 2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。</p>
<p>4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN&#x3D;1，ack&#x3D;u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq&#x3D;w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。</p>
<p>5）客户端收到服务器的连接释放报文后，必须发出确认，ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是 seq&#x3D;u+1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。注意此时 TCP 连接还没有释放，必须经过 2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态。</p>
<p>6）服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。可以看到，服务器结束 TCP 连接的时间要比客户端早一些。</p>
<h4 id="TCP-x2F-IP-x2F-如何保证数据包传输的有序可靠？"><a href="#TCP-x2F-IP-x2F-如何保证数据包传输的有序可靠？" class="headerlink" title="TCP&#x2F;IP &#x2F; 如何保证数据包传输的有序可靠？"></a><strong>TCP&#x2F;IP &#x2F; 如何保证数据包传输的有序可靠？</strong></h4><p>对字节流分段并进行编号然后通过 ACK 回复和超时重发这两个机制来保证。</p>
<p>（1）为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区；<br>（2）并为每个已发送的数据包启动一个超时定时器；<br>（3）如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区;<br>（4）否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。<br>（5）接收方收到数据包后，先进行 CRC 校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。</p>
<h4 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a><strong>TCP 和 UDP 的区别</strong></h4><ol>
<li>TCP 是面向链接的，而 UDP 是面向无连接的。</li>
<li>TCP 仅支持单播传输，UDP 提供了单播，多播，广播的功能。</li>
<li>TCP 的三次握手保证了连接的可靠性; UDP 是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。</li>
<li>UDP 的头部开销比 TCP 的更小，数据传输速率更高，实时性更好。</li>
</ol>
<h4 id="HTTP-请求跨域问题"><a href="#HTTP-请求跨域问题" class="headerlink" title="HTTP 请求跨域问题"></a><strong>HTTP 请求跨域问题</strong></h4><ol>
<li><p>跨域的原理</p>
<p><strong>跨域</strong>，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的。<br><strong>同源策略</strong>,是浏览器对 JavaScript 实施的安全限制，只要协议、域名、端口有任何一个不同，都被当作是不同的域。<br><strong>跨域原理</strong>，即是通过各种方式，避开浏览器的安全限制。</p>
</li>
<li><p>解决方案</p>
<p>最初做项目的时候，使用的是 jsonp，但存在一些问题，使用 get 请求不安全，携带数据较小，后来也用过 iframe，但只有主域相同才行，也是存在些问题，后来通过了解和学习发现使用代理和 proxy 代理配合起来使用比较方便，就引导后台按这种方式做下服务器配置，在开发中使用 proxy，在服务器上使用 nginx 代理，这样开发过程中彼此都方便，效率也高；现在 h5 新特性还有 windows.postMessage()</p>
<ol>
<li><p><strong>JSONP</strong>：<br>ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链 接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是 返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。</p>
<p>步骤：</p>
<ol>
<li>去创建一个 script 标签</li>
<li>script 的 src 属性设置接口地址</li>
<li>接口参数，必须要带一个自定义函数名，要不然后台无法返回数据</li>
<li>通过定义函数名去接受返回的数据</li>
</ol>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态创建 script</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置 script 的 src 属性，并设置请求地址</span></span><br><span class="line"></span><br><span class="line">script.<span class="property">src</span> = <span class="string">&#x27;http://localhost:3000/?callback=getData&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 让 script 生效</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script)</span><br></pre></td></tr></table></figure></div>

<p><strong>JSONP 的缺点:</strong><br>JSON 只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。</p>
</li>
<li><p><strong>document.domain</strong> 基础域名相同 子域名不同</p>
</li>
<li><p><strong>window.name</strong> 利用在一个浏览器窗口内，载入所有的域名都是共享一个 window.name</p>
</li>
<li><p><strong>CORS</strong> CORS(Cross-origin resource sharing)跨域资源共享 服务器设置对 CORS 的支持原理：服务器设置 Access-Control-Allow-Origin HTTP 响应头之后，浏览器将会允许跨域请求</p>
</li>
<li><p><strong>proxy 代理</strong> 目前常用方式,通过服务器设置代理</p>
</li>
<li><p><strong>window.postMessage()</strong> 利用 h5 新特性 window.postMessage()</p>
</li>
</ol>
</li>
</ol>
<h4 id="Cookie、sessionStorage、localStorage-的区别"><a href="#Cookie、sessionStorage、localStorage-的区别" class="headerlink" title="Cookie、sessionStorage、localStorage 的区别"></a><strong>Cookie、sessionStorage、localStorage 的区别</strong></h4><p><strong>相同点</strong></p>
<ul>
<li><p>存储在客户端</p>
<p><strong>不同点</strong></p>
</li>
<li><p>cookie 数据大小不能超过 4k；sessionStorage 和 localStorage 的存储比 cookie 大得多，可以达到 5M+</p>
</li>
<li><p>cookie 设置的过期时间之前一直有效；localStorage 永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage 数据在当前浏览器窗口关闭后自动删除</p>
</li>
<li><p>cookie 的数据会自动的传递到服务器；sessionStorage 和 localStorage 数据保存在本地</p>
</li>
</ul>
<p><strong>粘包问题分析与对策</strong></p>
<p>TCP 粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p>
<p><strong>粘包出现原因</strong></p>
<p>简单得说，在流传输中出现，UDP 不会出现粘包，因为它有<strong>消息边界</strong></p>
<p>粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包。</p>
<p>为了<strong>避免粘包</strong>现象，可采取以下几种措施：</p>
<p>（1）对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP 提供了强制数据立即传送的操作指令 push，TCP 软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；</p>
<p>（2）对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；</p>
<p>（3）由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。分包多发。</p>
<p>以上提到的三种措施，都有其不足之处。</p>
<p>（1）第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。</p>
<p>（2）第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。</p>
<p>（3）第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。</p>
<p>一种比较周全的对策是：接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开。实验证明这种方法是高效可行的。</p>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h4 id="从输入-URL-到页面加载的全过程"><a href="#从输入-URL-到页面加载的全过程" class="headerlink" title="从输入 URL 到页面加载的全过程"></a>从输入 URL 到页面加载的全过程</h4><ol>
<li>首先在浏览器中输入 URL</li>
<li>查找缓存：浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。<ol>
<li>浏览器缓存：浏览器会记录 DNS 一段时间，因此，只是第一个地方解析 DNS 请求；</li>
<li>操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的 DNS 查询缓存)；</li>
<li>路由器缓存：如果上述两个步骤均不能成功获取 DNS 记录，继续搜索路由器缓存；</li>
<li>ISP 缓存：若上述均失败，继续向 ISP 搜索。</li>
</ol>
</li>
<li>DNS 域名解析：浏览器向 DNS 服务器发起请求，解析该 URL 中的域名对应的 IP 地址。DNS 服务器是基于 UDP 的，因此会用到 UDP 协议。</li>
<li>建立 TCP 连接：解析出 IP 地址后，根据 IP 地址和默认 80 端口，和服务器建立 TCP 连接</li>
<li>发起 HTTP 请求：浏览器发起读取文件的 HTTP 请求，，该请求报文作为 TCP 三次握手的第三次数据发送给服务器</li>
<li>服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的 html 文件发送给浏览器</li>
<li>关闭 TCP 连接：通过四次挥手释放 TCP 连接</li>
<li>浏览器渲染：客户端（浏览器）解析 HTML 内容并渲染出来，浏览器接收到数据包后的解析流程为：<ol>
<li>构建 DOM 树：词法分析然后解析成 DOM 树（dom tree），是由 dom 元素及属性节点组成，树的根是 document 对象</li>
<li>构建 CSS 规则树：生成 CSS 规则树（CSS Rule Tree）</li>
<li>构建 render 树：Web 浏览器将 DOM 和 CSSOM 结合，并构建出渲染树（render tree）</li>
<li>布局（Layout）：计算出每个节点在屏幕中的位置</li>
<li>绘制（Painting）：即遍历 render 树，并使用 UI 后端层绘制每个节点。</li>
</ol>
</li>
<li>JS 引擎解析过程：调用 JS 引擎执行 JS 代码（JS 的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）<ol>
<li>创建 window 对象：window 对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于 window 的属性和方法，而 DOM Tree 也会映射在 window 的 doucment 对象上。当关闭网页或者关闭浏览器时，全局执行环境会被销毁。</li>
<li>加载文件：完成 js 引擎分析它的语法与词法是否合法，如果合法进入预编译</li>
<li>预编译：在预编译的过程中，浏览器会寻找全局变量声明，把它作为 window 的属性加入到 window 对象中，并给变量赋值为’undefined’；寻找全局函数声明，把它作为 window 的方法加入到 window 对象中，并将函数体赋值给他（匿名函数是不参与预编译的，因为它是变量）。而变量提升作为不合理的地方在 ES6 中已经解决了，函数提升还存在。</li>
<li>解释执行：执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在 ES5 非严格模式下这个变量会成为 window 的一个属性，也就是成为全局变量。string、int 这样的值就是直接把值放在变量的存储空间里，object 对象就是把指针指向变量的存储空间。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。JS 作用域其实就是这样的执行流机制实现的。</li>
</ol>
</li>
</ol>
<p>传送门 ☞ <a class="link"   href="https://juejin.cn/post/7005468491067162655" ># DNS 域名解析过程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ☞<a class="link"   href="https://juejin.cn/post/6992597760935460901" ># 浏览器的工作原理 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h4 id="浏览器重绘与重排的区别？"><a href="#浏览器重绘与重排的区别？" class="headerlink" title="浏览器重绘与重排的区别？"></a>浏览器重绘与重排的区别？</h4><ul>
<li>重排&#x2F;回流（Reflow）：当 DOM 的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。</li>
<li>重绘(Repaint): 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变</li>
</ul>
<p>单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分</p>
<p>重排和重绘代价是高昂的，它们会破坏用户体验，并且让 UI 展示非常迟缓，而相比之下重排的性能影响更大，在两者无法避免的情况下，一般我们宁可选择代价更小的重绘。</p>
<p>『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』。</p>
<h4 id="如何触发重排和重绘？"><a href="#如何触发重排和重绘？" class="headerlink" title="如何触发重排和重绘？"></a>如何触发重排和重绘？</h4><p>任何改变用来构建渲染树的信息都会导致一次重排或重绘：</p>
<ul>
<li>添加、删除、更新 DOM 节点</li>
<li>通过 display: none 隐藏一个 DOM 节点-触发重排和重绘</li>
<li>通过 visibility: hidden 隐藏一个 DOM 节点-只触发重绘，因为没有几何变化</li>
<li>移动或者给页面中的 DOM 节点添加动画</li>
<li>添加一个样式表，调整样式属性</li>
<li>用户行为，例如调整窗口大小，改变字号，或者滚动。</li>
</ul>
<h4 id="如何避免重绘或者重排？"><a href="#如何避免重绘或者重排？" class="headerlink" title="如何避免重绘或者重排？"></a><strong>如何避免重绘或者重排？</strong></h4><ol>
<li><p>集中改变样式，不要一条一条地修改 DOM 的样式。</p>
</li>
<li><p>不要把 DOM 结点的属性值放在循环里当成循环里的变量。</p>
</li>
<li><p>为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。</p>
</li>
<li><p>不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。</p>
</li>
<li><p>尽量只修改 position：absolute 或 fixed 元素，对其他元素影响不大</p>
</li>
<li><p>动画开始 GPU 加速，translate 使用 3D 变化</p>
</li>
<li><p>提升为合成层</p>
<p>将元素提升为合成层有以下优点：</p>
<ol>
<li><p>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</p>
</li>
<li><p>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</p>
</li>
<li><p>对于 transform 和 opacity 效果，不会触发 layout 和 paint</p>
<p>提升合成层的最好方式是使用 CSS 的 will-change 属性：</p>
<p>#target {</p>
<p>will-change: transform;</p>
<p>}</p>
<p>复制代码</p>
<p>关于合成层的详解请移步<a class="link"   href="https://link.juejin.cn/?target=http://taobaofed.org/blog/2016/04/25/performance-composite/" >无线性能优化：Composite <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
</ol>
</li>
</ol>
<h4 id="介绍下-304-过程"><a href="#介绍下-304-过程" class="headerlink" title="介绍下 304 过程"></a><strong>介绍下 304 过程</strong></h4><ul>
<li>a. 浏览器请求资源时首先命中资源的 Expires 和 Cache-Control，Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效，可以通过 Cache-control: max-age 指定最大生命周期，状态仍然返回 200，但不会请求数据，在浏览器中能明显看到 from cache 字样。</li>
<li>b. 强缓存失效，进入协商缓存阶段，首先验证 ETagETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化。服务器根据客户端上送的 If-None-Match 值来判断是否命中缓存。</li>
<li>c. 协商缓存 Last-Modify&#x2F;If-Modify-Since 阶段，客户端第一次请求资源时，服务服返回的 header 中会加上 Last-Modify，Last-modify 是一个时间标识该资源的最后修改时间。再次请求该资源时，request 的请求头中会包含 If-Modify-Since，该值为缓存之前返回的 Last-Modify。服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。</li>
</ul>
<h4 id="浏览器的缓存机制-强制缓存-amp-amp-协商缓存"><a href="#浏览器的缓存机制-强制缓存-amp-amp-协商缓存" class="headerlink" title="浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存"></a><strong>浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存</strong></h4><p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起 HTTP 请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中 HTTP 头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：</p>
<p>由上图我们可以知道：</p>
<ul>
<li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</li>
<li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li>
</ul>
<p>以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了。为了方便理解，这里根据是否需要向服务器重新发起 HTTP 请求将缓存过程分为两个部分，分别是强制缓存和协商缓存。</p>
<ul>
<li><p><strong>强制缓存</strong></p>
<p>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。当浏览器向服务器发起请求时，服务器会将缓存规则放入 HTTP 响应报文的 HTTP 头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 Expires 和 Cache-Control，其中 Cache-Control 优先级比 Expires 高。</p>
<p>强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：</p>
<ul>
<li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。</li>
<li>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。</li>
<li>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果</li>
</ul>
</li>
<li><p><strong>协商缓存</strong></p>
<p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，同样，协商缓存的标识也是在响应报文的 HTTP 头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified &#x2F; If-Modified-Since 和 Etag &#x2F; If-None-Match，其中 Etag &#x2F; If-None-Match 的优先级比 Last-Modified &#x2F; If-Modified-Since 高。协商缓存主要有以下两种情况：</p>
<ul>
<li>协商缓存生效，返回 304</li>
<li>协商缓存失效，返回 200 和请求结果结果</li>
</ul>
</li>
</ul>
<p>传送门 ☞ <a class="link"   href="https://juejin.cn/post/6992843117963509791" ># 彻底理解浏览器的缓存机制 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h4 id="说下进程、线程和协程"><a href="#说下进程、线程和协程" class="headerlink" title="说下进程、线程和协程"></a>说下进程、线程和协程</h4><p><strong>进程</strong>是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。</p>
<p><strong>线程</strong>是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程 ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。</p>
<p><strong>协程</strong>，英文 Coroutines，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。</p>
<p><strong>进程和线程的区别与联系</strong></p>
<p>【区别】：<br>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；<br>并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；<br>拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。<br>系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</p>
<p>【联系】： 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；<br>资源分配给进程，同一进程的所有线程共享该进程的所有资源；<br>处理机分给线程，即真正在处理机上运行的是线程；<br>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</p>
<p>传送门 ☞ <a class="link"   href="https://juejin.cn/post/7005465381791875109" ># 一文搞懂进程、线程、协程及 JS 协程的发展 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> <a class="link"   href="https://link.juejin.cn/?target=http://www.360doc.com/content/20/0417/14/32196507_906628857.shtml" >☞ 了解更多 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>关于浏览器传送门 ☞<a class="link"   href="https://juejin.cn/post/6993095345576083486" ># 深入了解现代 Web 浏览器 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="HTML-amp-amp-CSS"><a href="#HTML-amp-amp-CSS" class="headerlink" title="HTML &amp;&amp; CSS"></a>HTML &amp;&amp; CSS</h2><h4 id="HTML5-新特性、语义化"><a href="#HTML5-新特性、语义化" class="headerlink" title="HTML5 新特性、语义化"></a><strong>HTML5 新特性、语义化</strong></h4><ol>
<li><p><strong>概念</strong>：</p>
<p>HTML5 的语义化指的是合理正确的使用语义化的标签来创建页面结构。【正确的标签做正确的事】</p>
</li>
<li><p><strong>语义化标签</strong>：</p>
<p>header nav main article section aside footer</p>
</li>
<li><p><strong>语义化的优点</strong>:</p>
<ol>
<li>在没 CSS 样式的情况下，页面整体也会呈现很好的结构效果</li>
<li>代码结构清晰，易于阅读，</li>
<li>利于开发和维护 方便其他设备解析（如屏幕阅读器）根据语义渲染网页。</li>
<li>有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重</li>
</ol>
</li>
</ol>
<h4 id="CSS-选择器及优先级"><a href="#CSS-选择器及优先级" class="headerlink" title="CSS 选择器及优先级"></a><strong>CSS 选择器及优先级</strong></h4><p><strong>选择器</strong></p>
<ul>
<li>id 选择器(#myid)</li>
<li>类选择器(.myclass)</li>
<li>属性选择器(a[rel&#x3D;”external”])</li>
<li>伪类选择器(a:hover, li:nth-child)</li>
<li>标签选择器(div, h1,p)</li>
<li>相邻选择器（h1 + p）</li>
<li>子选择器(ul &gt; li)</li>
<li>后代选择器(li a)</li>
<li>通配符选择器(*)</li>
</ul>
<p><strong>优先级：</strong></p>
<ul>
<li>!important</li>
<li>内联样式（1000）</li>
<li>ID 选择器（0100）</li>
<li>类选择器&#x2F;属性选择器&#x2F;伪类选择器（0010）</li>
<li>元素选择器&#x2F;伪元素选择器（0001）</li>
<li>关系选择器&#x2F;通配符选择器（0000）</li>
</ul>
<p>带!important 标记的样式属性优先级最高； 样式表的来源相同时：!important &gt; 行内样式&gt;ID 选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</p>
<h4 id="position-属性的值有哪些及其区别"><a href="#position-属性的值有哪些及其区别" class="headerlink" title="position 属性的值有哪些及其区别"></a><strong>position 属性的值有哪些及其区别</strong></h4><p><strong>固定定位 fixed</strong>： 元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed 定 位使元素的位置与文档流无关，因此不占据空间。 Fixed 定位的元素和其他元素重叠。</p>
<p><strong>相对定位 relative</strong>： 如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直 或水平位置，让这个元素“相对于”它的起点进行移动。 在使用相对定位时，无论是 否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。</p>
<p><strong>绝对定位 absolute</strong>： 绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那 么它的位置相对于。absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute 定位的元素和其他元素重叠。</p>
<p><strong>粘性定位 sticky</strong>： 元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定 位，之后为固定定位。</p>
<p><strong>默认定位 Static</strong>： 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声 明）。 inherit: 规定应该从父元素继承 position 属性的值。</p>
<h4 id="box-sizing-属性"><a href="#box-sizing-属性" class="headerlink" title="box-sizing 属性"></a><strong>box-sizing 属性</strong></h4><p>box-sizing 规定两个并排的带边框的框，语法为 box-sizing：content-box&#x2F;border-box&#x2F;inherit</p>
<p><strong>content-box</strong>：宽度和高度分别应用到元素的内容框，在宽度和高度之外绘制元素的内边距和边框。【标准盒子模型】</p>
<p><strong>border-box</strong>：为元素设定的宽度和高度决定了元素的边框盒。【IE 盒子模型】</p>
<p><strong>inherit</strong>：继承父元素的 box-sizing 值。</p>
<h4 id="CSS-盒子模型"><a href="#CSS-盒子模型" class="headerlink" title="CSS 盒子模型"></a><strong>CSS 盒子模型</strong></h4><p>CSS 盒模型本质上是一个盒子，它包括：边距，边框，填充和实际内容。CSS 中的盒子模型包括 IE 盒子模型和标准的 W3C 盒子模型。<br>在标准的盒子模型中，width 指 content 部分的宽度。<br>在 IE 盒子模型中，width 表示 content+padding+border 这三个部分的宽度。</p>
<p>故在计算盒子的宽度时存在差异：</p>
<p><strong>标准盒模型：</strong> 一个块的总宽度 &#x3D; width+margin(左右)+padding(左右)+border(左右)</p>
<p><strong>怪异盒模型：</strong> 一个块的总宽度 &#x3D; width+margin（左右）（既 width 已经包含了 padding 和 border 值）</p>
<h4 id="BFC（块级格式上下文）"><a href="#BFC（块级格式上下文）" class="headerlink" title="BFC（块级格式上下文）"></a><strong>BFC（块级格式上下文）</strong></h4><p><strong>BFC 的概念</strong></p>
<p>BFC 是 Block Formatting Context 的缩写，即块级格式化上下文。BFC 是 CSS 布局的一个概念，是一个独立的渲染区域，规定了内部 box 如何布局， 并且这个区域的子元素不会影响到外面的元素，其中比较重要的布局规则有内部 box 垂直放置，计算 BFC 的高度的时候，浮动元素也参与计算。</p>
<p><strong>BFC 的原理布局规则</strong></p>
<ul>
<li>内部的 Box 会在垂直方向，一个接一个地放置</li>
<li>Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠</li>
<li>每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往右的格式化，否则相反</li>
<li>BFC 的区域不会与 float box 重叠</li>
<li>BFC 是一个独立容器，容器里面的子元素不会影响到外面的元素</li>
<li>计算 BFC 的高度时，浮动元素也参与计算高度</li>
<li>元素的类型和 display 属性，决定了这个 Box 的类型。不同类型的 Box 会参与不同的 Formatting Context。</li>
</ul>
<p><strong>如何创建 BFC？</strong></p>
<ul>
<li>根元素，即 HTML 元素</li>
<li>float 的值不为 none</li>
<li>position 为 absolute 或 fixed</li>
<li>display 的值为 inline-block、table-cell、table-caption</li>
<li>overflow 的值不为 visible</li>
</ul>
<p><strong>BFC 的使用场景</strong></p>
<ul>
<li>去除边距重叠现象</li>
<li>清除浮动（让父元素的高度包含子浮动元素）</li>
<li>避免某元素被浮动元素覆盖</li>
<li>避免多列布局由于宽度计算四舍五入而自动换行</li>
</ul>
<h4 id="让一个元素水平垂直居中"><a href="#让一个元素水平垂直居中" class="headerlink" title="让一个元素水平垂直居中"></a><strong>让一个元素水平垂直居中</strong></h4><ul>
<li><p><strong>水平居中</strong></p>
<ul>
<li><p>对于 行内元素 : text-align: center;</p>
</li>
<li><p>对于确定宽度的块级元素：</p>
<p>（1）width 和 margin 实现。margin: 0 auto;</p>
<p>（2）绝对定位和 margin-left: (父 width - 子 width）&#x2F;2, 前提是父元素 position: relative</p>
</li>
<li><p>对于宽度未知的块级元素</p>
<p>（1）table 标签配合 margin 左右 auto 实现水平居中。使用 table 标签（或直接将块级元素设值为 display:table），再通过给该标签添加左右 margin 为 auto。</p>
<p>（2）inline-block 实现水平居中方法。display：inline-block 和 text-align:center 实现水平居中。</p>
<p>（3）绝对定位+transform，translateX 可以移动本身元素的 50%。</p>
<p>（4）flex 布局使用 justify-content:center</p>
</li>
</ul>
</li>
<li><p><strong>垂直居中</strong></p>
<ul>
<li>利用 line-height 实现居中，这种方法适合纯文字类</li>
<li>通过设置父容器 相对定位 ，子级设置 绝对定位，标签通过 margin 实现自适应居中</li>
<li>弹性布局 flex :父级设置 display: flex; 子级设置 margin 为 auto 实现自适应居中</li>
<li>父级设置相对定位，子级设置绝对定位，并且通过位移 transform 实现</li>
<li>table 布局，父级通过转换成表格形式，然后子级设置 vertical-align 实现。（需要注意的是：vertical-align: middle 使用的前提条件是内联元素以及 display 值为 table-cell 的元素）。</li>
</ul>
</li>
</ul>
<p>传送门 ☞ <a class="link"   href="https://juejin.cn/post/7008348524530106381" ># 图解 CSS 水平垂直居中常见面试方法 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h4 id="隐藏页面中某个元素的方法"><a href="#隐藏页面中某个元素的方法" class="headerlink" title="隐藏页面中某个元素的方法"></a><strong>隐藏页面中某个元素的方法</strong></h4><p>1.opacity：0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定 一些事件，如 click 事件，那么点击该区域，也能触发点击事件的</p>
<p>2.visibility：hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已 经绑定的事件 ，隐藏对应元素，在文档布局中仍保留原来的空间（重绘）</p>
<p>3.display：none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素。 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）</p>
<p>该问题会引出 回流和重绘</p>
<h4 id="用-CSS-实现三角符号"><a href="#用-CSS-实现三角符号" class="headerlink" title="用 CSS 实现三角符号"></a><strong>用 CSS 实现三角符号</strong></h4><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/\*记忆口诀：盒子宽高均为零，三面边框皆透明。 \*/</span><br><span class="line"></span><br><span class="line"><span class="attr">div</span>:after&#123;</span><br><span class="line"><span class="attr">position</span>: absolute;</span><br><span class="line"><span class="attr">width</span>: 0px;</span><br><span class="line"><span class="attr">height</span>: 0px;</span><br><span class="line"><span class="attr">content</span>: <span class="string">&quot; &quot;</span>;</span><br><span class="line">border-<span class="attr">right</span>: 100px solid transparent;</span><br><span class="line">border-<span class="attr">top</span>: 100px solid \#ff0;</span><br><span class="line">border-<span class="attr">left</span>: 100px solid transparent;</span><br><span class="line">border-<span class="attr">bottom</span>: 100px solid transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a><strong>页面布局</strong></h4><p><strong>1.Flex 布局</strong></p>
<p>布局的传统解决方案，基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。</p>
<p>Flex 是 Flexible Box 的缩写，意为”弹性布局”,用来为盒状模型提供最大的灵活性。指定容器 display: flex 即可。 简单的分为容器属性和元素属性。</p>
<p>容器的属性：</p>
<ul>
<li>flex-direction：决定主轴的方向（即子 item 的排列方法）flex-direction: row | row-reverse | column | column-reverse;</li>
<li>flex-wrap：决定换行规则 flex-wrap: nowrap | wrap | wrap-reverse;</li>
<li>flex-flow： .box { flex-flow: || ; }</li>
<li>justify-content：对其方式，水平主轴对齐方式</li>
<li>align-items：对齐方式，竖直轴线方向</li>
<li>align-content</li>
</ul>
<p>项目的属性（元素的属性）：</p>
<ul>
<li>order 属性：定义项目的排列顺序，顺序越小，排列越靠前，默认为 0</li>
<li>flex-grow 属性：定义项目的放大比例，即使存在空间，也不会放大</li>
<li>flex-shrink 属性：定义了项目的缩小比例，当空间不足的情况下会等比例的缩小，如果 定义个 item 的 flow-shrink 为 0，则为不缩小</li>
<li>flex-basis 属性：定义了在分配多余的空间，项目占据的空间。</li>
<li>flex：是 flex-grow 和 flex-shrink、flex-basis 的简写，默认值为 0 1 auto。</li>
<li>align-self：允许单个项目与其他项目不一样的对齐方式，可以覆盖</li>
<li>align-items，默认属 性为 auto，表示继承父元素的 align-items 比如说，用 flex 实现圣杯布局</li>
</ul>
<p><strong>2.Rem 布局</strong></p>
<p>首先 Rem 相对于根(html)的 font-size 大小来计算。简单的说它就是一个相对单例 如:font-size:10px;,那么（1rem &#x3D; 10px）了解计算原理后首先解决怎么在不同设备上设置 html 的 font-size 大小。其实 rem 布局的本质是等比缩放，一般是基于宽度。</p>
<p><strong>优点</strong>：可以快速适用移动端布局，字体，图片高度</p>
<p><strong>缺点</strong>：</p>
<p>① 目前 ie 不支持，对 pc 页面来讲使用次数不多；<br>② 数据量大：所有的图片，盒子都需要我们去给一个准确的值；才能保证不同机型的适配；<br>③ 在响应式布局中，必须通过 js 来动态控制根元素 font-size 的大小。也就是说 css 样式和 js 代码有一定的耦合性。且必须将改变 font-size 的代码放在 css 样式之前。</p>
<p><strong>3.百分比布局</strong></p>
<p>通过百分比单位 “ % “ 来实现响应式的效果。通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。 直观的理解，我们可能会认为子元素的百分比完全相对于直接父元素，height 百分比相 对于 height，width 百分比相对于 width。 padding、border、margin 等等不论是垂直方向还是水平方向，都相对于直接父元素的 width。 除了 border-radius 外，还有比如 translate、background-size 等都是相对于自身的。</p>
<p><strong>缺点</strong>：</p>
<p>（1）计算困难<br>（2）各个属性中如果使用百分比，相对父元素的属性并不是唯一的。造成我们使用百分比单位容易使布局问题变得复杂。</p>
<p><strong>4.浮动布局</strong></p>
<p>浮动布局:当元素浮动以后可以向左或向右移动，直到它的外边缘碰到包含它的框或者另外一个浮动元素的边框为止。元素浮动以后会脱离正常的文档流，所以文档的普通流中的框就变的好像浮动元素不存在一样。</p>
<p><strong>优点</strong></p>
<p>这样做的优点就是在图文混排的时候可以很好的使文字环绕在图片周围。另外当元素浮动了起来之后，它有着块级元素的一些性质例如可以设置宽高等，但它与 inline-block 还是有一些区别的，第一个就是关于横向排序的时候，float 可以设置方向而 inline-block 方向是固定的；还有一个就是 inline-block 在使用时有时会有空白间隙的问题</p>
<p><strong>缺点</strong></p>
<p>最明显的缺点就是浮动元素一旦脱离了文档流，就无法撑起父元素，会造成父级元素高度塌陷。</p>
<p><strong>如何使用 rem 或 viewport 进行移动端适配</strong></p>
<p><strong>rem 适配原理：</strong></p>
<p>改变了一个元素在不同设备上占据的 css 像素的个数</p>
<p>rem 适配的优缺点</p>
<ul>
<li>优点：没有破坏完美视口</li>
<li>缺点：px 值转换 rem 太过于复杂(下面我们使用 less 来解决这个问题)</li>
</ul>
<p><strong>viewport 适配的原理</strong></p>
<p>viewport 适配方案中，每一个元素在不同设备上占据的 css 像素的个数是一样的。但是 css 像素和物理像素的比例是不一样的，等比的</p>
<p>viewport 适配的优缺点</p>
<ul>
<li>在我们设计图上所量取的大小即为我们可以设置的像素大小，即所量即所设</li>
<li>缺点破坏完美视口</li>
</ul>
<p><strong>清除浮动的方式</strong></p>
<ul>
<li>添加额外标签</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">\&lt;div <span class="keyword">class</span>=<span class="string">&quot;parent&quot;</span>\&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加额外标签并且添加 clear 属性</span></span><br><span class="line"></span><br><span class="line">\&lt;div style=<span class="string">&quot;clear:both&quot;</span>\&gt;\&lt;/div\&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以加一个 br 标签</span></span><br><span class="line"></span><br><span class="line">\&lt;/div\&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>父级添加 overflow 属性，或者设置高度</li>
<li>建立伪类选择器清除浮动</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在 css 中添加:after 伪元素</span></span><br><span class="line"></span><br><span class="line">.<span class="property">parent</span>:after&#123;</span><br><span class="line"></span><br><span class="line"><span class="regexp">/\* 设置添加子元素的内容是空 \*/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">/\* 设置添加子元素为块级元素 \*/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">display</span>: block;</span><br><span class="line"></span><br><span class="line"><span class="regexp">/\* 设置添加的子元素的高度 0 \*/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">height</span>: <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">/\* 设置添加子元素看不见 \*/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">visibility</span>: hidden;</span><br><span class="line"></span><br><span class="line"><span class="regexp">/\* 设置 clear：both \*/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">clear</span>: both;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="JS、TS、ES6"><a href="#JS、TS、ES6" class="headerlink" title="JS、TS、ES6"></a><strong>JS、TS、ES6</strong></h2><h4 id="JS-中的-8-种数据类型及区别"><a href="#JS-中的-8-种数据类型及区别" class="headerlink" title="JS 中的 8 种数据类型及区别"></a><strong>JS 中的 8 种数据类型及区别</strong></h4><p>包括值类型(基本对象类型)和引用类型(复杂对象类型)</p>
<p><strong>基本类型(值类型)：</strong> Number(数字),String(字符串),Boolean(布尔),Symbol(符号),null(空),undefined(未定义)在内存中占据固定大小，保存在栈内存中</p>
<p><strong>引用类型(复杂数据类型)：</strong> Object(对象)、Function(函数)。其他还有 Array(数组)、Date(日期)、RegExp(正则表达式)、特殊的基本包装类型(String、Number、Boolean) 以及单体内置对象(Global、Math)等 引用类型的值是对象 保存在堆内存中，栈内存存储的是对象的变量标识符以及对象在堆内存中的存储地址。</p>
<p>传送门 ☞<a class="link"   href="https://juejin.cn/post/7000754813801775111" ># JavaScript 数据类型之 Symbol、BigInt <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h4 id="JS-中的数据类型检测方案"><a href="#JS-中的数据类型检测方案" class="headerlink" title="JS 中的数据类型检测方案"></a><strong>JS 中的数据类型检测方案</strong></h4><p><strong>1.typeof</strong></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">1</span>) <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>) <span class="comment">// boolean</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&#x27;mc&#x27;</span>) <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Symbol</span>) <span class="comment">// function</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Symbol</span>()) <span class="comment">// symbol</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;) <span class="comment">// function</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="variable language_">console</span>.<span class="title function_">log</span>()) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> []) <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> &#123;&#125;) <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>) <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></div>

<p>优点：能够快速区分基本数据类型</p>
<p>缺点：不能将 Object、Array 和 Null 区分，都返回 object</p>
<p><strong>2.instanceof</strong></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> <span class="keyword">instanceof</span> <span class="title class_">Number</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="title class_">Boolean</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="title class_">String</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] <span class="keyword">instanceof</span> <span class="title class_">Array</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Function</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Object</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<p>优点：能够区分 Array、Object 和 Function，适合用于判断自定义的类实例对象</p>
<p>缺点：Number，Boolean，String 基本数据类型不能判断</p>
<p><strong>3.Object.prototype.toString.call()</strong></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> toString = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(toString.<span class="title function_">call</span>(<span class="number">1</span>)) <span class="comment">//[object Number]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(toString.<span class="title function_">call</span>(<span class="literal">true</span>)) <span class="comment">//[object Boolean]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(toString.<span class="title function_">call</span>(<span class="string">&#x27;mc&#x27;</span>)) <span class="comment">//[object String]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(toString.<span class="title function_">call</span>([])) <span class="comment">//[object Array]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(toString.<span class="title function_">call</span>(&#123;&#125;)) <span class="comment">//[object Object]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(toString.<span class="title function_">call</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;)) <span class="comment">//[object Function]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(toString.<span class="title function_">call</span>(<span class="literal">undefined</span>)) <span class="comment">//[object Undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(toString.<span class="title function_">call</span>(<span class="literal">null</span>)) <span class="comment">//[object Null]</span></span><br></pre></td></tr></table></figure></div>

<p>优点：精准判断数据类型</p>
<p>缺点：写法繁琐不容易记，推荐进行封装后使用</p>
<h4 id="var-amp-amp-let-amp-amp-const"><a href="#var-amp-amp-let-amp-amp-const" class="headerlink" title="var &amp;&amp; let &amp;&amp; const"></a><strong>var &amp;&amp; let &amp;&amp; const</strong></h4><p>ES6 之前创建变量用的是 var,之后创建变量用的是 let&#x2F;const</p>
<p><strong>三者区别</strong>：</p>
<ol>
<li>var 定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。<br>let 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。<br>const 用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，且不能修改。</li>
<li>var 可以先使用，后声明，因为存在变量提升；let 必须先声明后使用。</li>
<li>var 是允许在相同作用域内重复声明同一个变量的，而 let 与 const 不允许这一现象。</li>
<li>在全局上下文中，基于 let 声明的全局变量和全局对象 GO（window）没有任何关系 ;<br>var 声明的变量会和 GO 有映射关系；</li>
<li>会产生暂时性死区：</li>
</ol>
<p>暂时性死区是浏览器的 bug：检测一个未被声明的变量类型时，不会报错，会返回 undefined<br>如：console.log(typeof a) &#x2F;&#x2F;undefined<br>而：console.log(typeof a)&#x2F;&#x2F;未声明之前不能使用<br>let a</p>
<ol>
<li>let &#x2F;const&#x2F;function 会把当前所在的大括号(除函数之外)作为一个全新的块级上下文，应用这个机制，在开发项目的时候，遇到循环事件绑定等类似的需求，无需再自己构建闭包来存储，只要基于 let 的块作用特征即可解决</li>
</ol>
<h4 id="JS-垃圾回收机制"><a href="#JS-垃圾回收机制" class="headerlink" title="JS 垃圾回收机制"></a><strong>JS 垃圾回收机制</strong></h4><ol>
<li><p>项目中，如果存在大量不被释放的内存（堆&#x2F;栈&#x2F;上下文），页面性能会变得很慢。当某些代码操作不能被合理释放，就会造成内存泄漏。我们尽可能减少使用闭包，因为它会消耗内存。</p>
</li>
<li><p>浏览器垃圾回收机制&#x2F;内存回收机制:</p>
<p>浏览器的 Javascript 具有自动垃圾回收机制(GC:Garbage Collecation)，垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。</p>
<p><strong>标记清除</strong>:在 js 中，最常用的垃圾回收机制是标记清除：当变量进入执行环境时，被标记为“进入环境”，当变量离开执行环境时，会被标记为“离开环境”。垃圾回收器会销毁那些带标记的值并回收它们所占用的内存空间。<br><strong>谷歌浏览器</strong>：“查找引用”，浏览器不定时去查找当前内存的引用，如果没有被占用了，浏览器会回收它；如果被占用，就不能回收。<br><strong>IE 浏览器</strong>：“引用计数法”，当前内存被占用一次，计数累加 1 次，移除占用就减 1，减到 0 时，浏览器就回收它。</p>
</li>
<li><p>优化手段：内存优化 ; 手动释放：取消内存的占用即可。</p>
<p>（1）堆内存：fn &#x3D; null 【null：空指针对象】</p>
<p>（2）栈内存：把上下文中，被外部占用的堆的占用取消即可。</p>
</li>
<li><p>内存泄漏</p>
<p>在 JS 中，常见的内存泄露主要有 4 种,全局变量、闭包、DOM 元素的引用、定时器</p>
</li>
</ol>
<h4 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a><strong>作用域和作用域链</strong></h4><p>创建函数的时候，已经声明了当前函数的作用域&#x3D;&#x3D;&gt;当前创建函数所处的上下文。如果是在全局下创建的函数就是[[scope]]:EC(G)，函数执行的时候，形成一个全新的私有上下文 EC(FN)，供字符串代码执行(进栈执行)</p>
<p>定义：简单来说作用域就是变量与函数的可访问范围，由当前环境与上层环境的一系列变量对象组成<br>1.全局作用域：代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域。<br>2.函数作用域：在固定的代码片段才能被访问</p>
<p>作用：作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</p>
<p><strong>作用域链参考链接</strong>一般情况下，变量到 创建该变量 的函数的作用域中取值。但是如果在当前作用域中没有查到，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。</p>
<h4 id="闭包的两大作用：保存-x2F-保护"><a href="#闭包的两大作用：保存-x2F-保护" class="headerlink" title="闭包的两大作用：保存&#x2F;保护"></a><strong>闭包的两大作用：保存&#x2F;保护</strong></h4><ul>
<li><p><strong>闭包的概念</strong></p>
<p>函数执行时形成的私有上下文 EC(FN)，正常情况下，代码执行完会出栈后释放;但是特殊情况下，如果当前私有上下文中的某个东西被上下文以外的事物占用了，则上下文不会出栈释放，从而形成不销毁的上下文。 函数执行函数执行过程中，会形成一个全新的私有上下文，可能会被释放，可能不会被释放，不论释放与否，他的作用是：</p>
</li>
</ul>
<p>（1）保护：划分一个独立的代码执行区域，在这个区域中有自己私有变量存储的空间，保护自己的私有变量不受外界干扰（操作自己的私有变量和外界没有关系）；</p>
<p>（2）保存：如果当前上下文不被释放【只要上下文中的某个东西被外部占用即可】，则存储的这些私有变量也不会被释放，可以供其下级上下文中调取使用，相当于把一些值保存起来了；</p>
<p>我们把函数执行形成私有上下文，来保护和保存私有变量机制称为闭包。</p>
<p>闭包是指有权访问另一个函数作用域中的变量的函数–《JavaScript 高级程序设计》</p>
<p><strong>稍全面的回答</strong>： 在 js 中变量的作用域属于函数作用域, 在函数执行完后,作用域就会被清理,内存也会随之被回收,但是由于闭包函数是建立在函数内部的子函数, 由于其可访问上级作用域,即使上级函数执行完, 作用域也不会随之销毁, 这时的子函数(也就是闭包),便拥有了访问上级作用域中变量的权限,即使上级函数执行完后作用域内的值也不会被销毁。</p>
<ul>
<li><p><strong>闭包的特性</strong>：</p>
<ul>
<li><p>1、内部函数可以访问定义他们外部函数的参数和变量。(作用域链的向上查找，把外围的作用域中的变量值存储在内存中而不是在函数调用完毕后销毁)设计私有的方法和变量，避免全局变量的污染。</p>
<p>1.1.闭包是密闭的容器，，类似于 set、map 容器，存储数据的</p>
<p>1.2.闭包是一个对象，存放数据的格式为 key-value 形式</p>
</li>
<li><p>2、函数嵌套函数</p>
</li>
<li><p>3、本质是将函数内部和外部连接起来。优点是可以读取函数内部的变量，让这些变量的值始终保存在内存中，不会在函数被调用之后自动清除</p>
</li>
</ul>
</li>
<li><p><strong>闭包形成的条件</strong>：</p>
<ul>
<li>函数的嵌套</li>
<li>内部函数引用外部函数的局部变量，延长外部函数的变量生命周期</li>
</ul>
</li>
<li><p><strong>闭包的用途</strong>：</p>
<ul>
<li>模仿块级作用域</li>
<li>保护外部函数的变量 能够访问函数定义时所在的词法作用域(阻止其被回收)</li>
<li>封装私有化变量</li>
<li>创建模块</li>
</ul>
</li>
<li><p><strong>闭包应用场景</strong></p>
<p>闭包的两个场景，闭包的两大作用：保存&#x2F;保护。 在开发中, 其实我们随处可见闭包的身影, 大部分前端 JavaScript 代码都是“事件驱动”的,即一个事件绑定的回调方法; 发送 ajax 请求成功|失败的回调;setTimeout 的延时回调;或者一个函数内部返回另一个匿名函数,这些都是闭包的应用。</p>
</li>
<li><p><strong>闭包的优点</strong>：延长局部变量的生命周期</p>
</li>
<li><p><strong>闭包缺点</strong>：会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏</p>
</li>
</ul>
<h4 id="JS-中-this-的五种情况"><a href="#JS-中-this-的五种情况" class="headerlink" title="JS 中 this 的五种情况"></a><strong>JS 中 this 的五种情况</strong></h4><ol>
<li>作为普通函数执行时，this 指向 window。</li>
<li>当函数作为对象的方法被调用时，this 就会指向该对象。</li>
<li>构造器调用，this 指向返回的这个对象。</li>
<li>箭头函数 箭头函数的 this 绑定看的是 this 所在函数定义在哪个对象下，就绑定哪个对象。如果有嵌套的情况，则 this 绑定到最近的一层对象上。</li>
<li>基于 Function.prototype 上的 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。apply 接收参数的是数组，call 接受参数列表，`` bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new `时会被改变，其他情况下都不会改变。若为空默认是指向全局对象 window。</li>
</ol>
<h4 id="原型-amp-amp-原型链"><a href="#原型-amp-amp-原型链" class="headerlink" title="原型 &amp;&amp; 原型链"></a><strong>原型 &amp;&amp; 原型链</strong></h4><p><strong>原型关系：</strong></p>
<ul>
<li>每个 class 都有显示原型 prototype</li>
<li>每个实例都有隐式原型 _ proto_</li>
<li>实例的_ proto_指向对应 class 的 prototype</li>
</ul>
<p>‌ <strong>原型:</strong> 在 JS 中，每当定义一个对象（函数也是对象）时，对象中都会包含一些预定义的属性。其中每个函数对象都有一个 prototype 属性，这个属性指向函数的原型对象。</p>
<p>原型链：函数的原型链对象 constructor 默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针<strong>proto</strong>,该指针是指向上一层的原型对象，而上一层的原型对象的结构依然类似。因此可以利用<strong>proto</strong>一直指向 Object 的原型对象上，而 Object 原型对象用 Object.prototype.<em>_ proto</em>_ &#x3D; null 表示原型链顶端。如此形成了 js 的原型链继承。同时所有的 js 对象都有 Object 的基本防范</p>
<p><strong>特点:</strong> JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p>
<h4 id="new-运算符的实现机制"><a href="#new-运算符的实现机制" class="headerlink" title="new 运算符的实现机制"></a><strong>new 运算符的实现机制</strong></h4><ol>
<li>首先创建了一个新的空对象</li>
<li>设置原型，将对象的原型设置为函数的 prototype 对象。</li>
<li>让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</li>
<li>判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</li>
</ol>
<h4 id="EventLoop-事件循环"><a href="#EventLoop-事件循环" class="headerlink" title="EventLoop 事件循环"></a><strong>EventLoop 事件循环</strong></h4><p>JS 是单线程的，为了防止一个函数执行时间过长阻塞后面的代码，所以会先将同步代码压入执行栈中，依次执行，将异步代码推入异步队列，异步队列又分为宏任务队列和微任务队列，因为宏任务队列的执行时间较长，所以微任务队列要优先于宏任务队列。微任务队列的代表就是，Promise.then，MutationObserver，宏任务的话就是 setImmediate setTimeout setInterval</p>
<p>JS 运行的环境。一般为浏览器或者 Node。 在浏览器环境中，有 JS 引擎线程和渲染线程，且两个线程互斥。 Node 环境中，只有 JS 线程。 不同环境执行机制有差异，不同任务进入不同 Event Queue 队列。 当主程结束，先执行准备好微任务，然后再执行准备好的宏任务，一个轮询结束。</p>
<p><strong>浏览器中的事件环（Event Loop)</strong></p>
<p>事件环的运行机制是，先会执行栈中的内容，栈中的内容执行后执行微任务，微任务清空后再执行宏任务，先取出一个宏任务，再去执行微任务，然后在取宏任务清微任务这样不停的循环。</p>
<ul>
<li>eventLoop 是由 JS 的宿主环境（浏览器）来实现的；</li>
<li>事件循环可以简单的描述为以下四个步骤:<ul>
<li>函数入栈，当 Stack 中执行到异步任务的时候，就将他丢给 WebAPIs,接着执行同步任务,直到 Stack 为空；</li>
<li>此期间 WebAPIs 完成这个事件，把回调函数放入队列中等待执行（微任务放到微任务队列，宏任务放到宏任务队列）</li>
<li>执行栈为空时，Event Loop 把微任务队列执行清空；</li>
<li>微任务队列清空后，进入宏任务队列，取队列的第一项任务放入 Stack(栈）中执行，执行完成后，查看微任务队列是否有任务，有的话，清空微任务队列。重复 4，继续从宏任务中取任务执行，执行完成之后，继续清空微任务，如此反复循环，直至清空所有的任务。</li>
</ul>
</li>
<li>浏览器中的任务源(task):<ul>
<li>宏任务(macrotask)：<br>宿主环境提供的，比如浏览器<br>ajax、setTimeout、setInterval、setTmmediate(只兼容 ie)、script、requestAnimationFrame、messageChannel、UI 渲染、一些浏览器 api</li>
<li>微任务(microtask)：<br>语言本身提供的，比如 promise.then<br>then、queueMicrotask(基于 then)、mutationObserver(浏览器提供)、messageChannel 、mutationObersve</li>
</ul>
</li>
</ul>
<p>传送门 ☞ <a class="link"   href="https://juejin.cn/post/7001881781125251086" ># 宏任务和微任务 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><strong>Node 环境中的事件环（Event Loop)</strong></p>
<p>Node 是基于 V8 引擎的运行在服务端的 JavaScript 运行环境，在处理高并发、I&#x2F;O 密集(文件操作、网络操作、数据库操作等)场景有明显的优势。虽然用到也是 V8 引擎，但由于服务目的和环境不同，导致了它的 API 与原生 JS 有些区别，其 Event Loop 还要处理一些 I&#x2F;O，比如新的网络连接等，所以 Node 的 Event Loop(事件环机制)与浏览器的是不太一样。</p>
<p>执行顺序如下：</p>
<ul>
<li>timers: 计时器，执行 setTimeout 和 setInterval 的回调</li>
<li>pending callbacks: 执行延迟到下一个循环迭代的 I&#x2F;O 回调</li>
<li>idle, prepare: 队列的移动，仅系统内部使用</li>
<li>poll 轮询: 检索新的 I&#x2F;O 事件;执行与 I&#x2F;O 相关的回调。事实上除了其他几个阶段处理的事情，其他几乎所有的异步都在这个阶段处理。</li>
<li>check: 执行 setImmediate 回调，setImmediate 在这里执行</li>
<li>close callbacks: 执行 close 事件的 callback，一些关闭的回调函数，如：socket.on(‘close’, …)</li>
</ul>
<h4 id="setTimeout、Promise、Async-x2F-Await-的区别"><a href="#setTimeout、Promise、Async-x2F-Await-的区别" class="headerlink" title="setTimeout、Promise、Async&#x2F;Await 的区别"></a><strong>setTimeout、Promise、Async&#x2F;Await 的区别</strong></h4><ol>
<li><p>setTimeout</p>
<p>settimeout 的回调函数放到宏任务队列里，等到执行栈清空以后执行。</p>
</li>
<li><p>Promise</p>
<p>Promise 本身是<strong>同步的立即执行函数</strong>， 当在 executor 中执行 resolve 或者 reject 的时候, 此时是异步操作， 会先执行 then&#x2F;catch 等，当主栈完成后，才会去调用 resolve&#x2F;reject 中存放的方法执行。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1 end&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;settimeout&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出顺序: script start-\&gt;promise1-\&gt;promise1 end-\&gt;script end-\&gt;promise2-\&gt;settimeout</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>async&#x2F;await</p>
</li>
</ol>
<p>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 start&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>()</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">async1</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出顺序：script start-\&gt;async1 start-\&gt;async2-\&gt;script end-\&gt;async1 end</span></span><br></pre></td></tr></table></figure></div>

<h4 id="Async-x2F-Await-如何通过同步的方式实现异步"><a href="#Async-x2F-Await-如何通过同步的方式实现异步" class="headerlink" title="Async&#x2F;Await 如何通过同步的方式实现异步"></a><strong>Async&#x2F;Await 如何通过同步的方式实现异步</strong></h4><p>Async&#x2F;Await 就是一个<strong>自执行</strong>的 generate 函数。利用 generate 函数的特性把异步的代码写成“同步”的形式,第一个请求的返回值作为后面一个请求的参数,其中每一个参数都是一个 promise 对象.</p>
<h4 id="介绍节流防抖原理、区别以及应用"><a href="#介绍节流防抖原理、区别以及应用" class="headerlink" title="介绍节流防抖原理、区别以及应用"></a><strong>介绍节流防抖原理、区别以及应用</strong></h4><p>节流：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次。</p>
<p>防抖：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如 1 秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待 1 秒，直到能最终执行！</p>
<p>使用场景：<br>节流：滚动加载更多、搜索框搜的索联想功能、高频点击、表单重复提交……<br>防抖：搜索框搜索输入，并在输入完以后自动搜索、手机号，邮箱验证输入检测、窗口大小 resize 变化后，再重新渲染。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">/\*\*</span><br><span class="line"></span><br><span class="line">\* 节流函数 一个函数执行一次后，只有大于设定的执行周期才会执行第二次。有个需要频繁触发的函数，出于优化性能的角度，在规定时间内，只让函数触发的第一次生效，后面的不生效。</span><br><span class="line"></span><br><span class="line">\* @param fn 要被节流的函数</span><br><span class="line"></span><br><span class="line">\* @param delay 规定的时间</span><br><span class="line"></span><br><span class="line">\*/</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录上一次函数触发的时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lastTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录当前函数触发的时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nowTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(nowTime - lastTime \&gt; delay)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修正 this 指向问题</span></span><br><span class="line"></span><br><span class="line">fn.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步执行结束时间</span></span><br><span class="line"></span><br><span class="line">lastTime = nowTime;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">onscroll</span> = <span class="title function_">throttle</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;scllor 事件被触发了&#x27;</span> + <span class="title class_">Date</span>.<span class="title function_">now</span>());</span><br><span class="line"></span><br><span class="line">&#125;, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">/\*\*</span><br><span class="line"></span><br><span class="line">\* 防抖函数 一个需要频繁触发的函数，在规定时间内，只让最后一次生效，前面的不生效</span><br><span class="line"></span><br><span class="line">\* @param fn 要被节流的函数</span><br><span class="line"></span><br><span class="line">\* @param delay 规定的时间</span><br><span class="line"></span><br><span class="line">\*/</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录上一次的延时器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清除上一次的演示器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">clearTimeout</span>(timer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新设置新的延时器</span></span><br><span class="line"></span><br><span class="line">timer = <span class="built_in">setTimeout</span>(()=\&gt;&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修正 this 指向问题</span></span><br><span class="line"></span><br><span class="line">fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">&#125;, delay);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>).<span class="property">onclick</span> = <span class="title function_">debounce</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;按钮被点击了&#x27;</span> + <span class="title class_">Date</span>.<span class="title function_">now</span>());</span><br><span class="line"></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="简述-MVVM"><a href="#简述-MVVM" class="headerlink" title="简述 MVVM"></a><strong>简述 MVVM</strong></h4><p><strong>什么是 MVVM？</strong></p>
<p>视图模型双向绑定，是 Model-View-ViewModel 的缩写，也就是把 MVC 中的 Controller 演变成 ViewModel。Model 层代表数据模型，View 代表 UI 组件，ViewModel 是 View 和 Model 层的桥梁，数据会绑定到 viewModel 层并自动将数据渲染到页面中，视图变化的时候会通知 viewModel 层更新数据。以前是操作 DOM 结构更新视图，现在是数据驱动视图。</p>
<p><strong>MVVM 的优点：</strong></p>
<p>1.低耦合。视图（View）可以独立于 Model 变化和修改，一个 Model 可以绑定到不同的 View 上，当 View 变化的时候 Model 可以不变化，当 Model 变化的时候 View 也可以不变； 2.可重用性。你可以把一些视图逻辑放在一个 Model 里面，让很多 View 重用这段视图逻辑。 3.独立开发。开发人员可以专注于业务逻辑和数据的开发(ViewModel)，设计人员可以专注于页面设计。 4.可测试。</p>
<h4 id="Vue-底层实现原理"><a href="#Vue-底层实现原理" class="headerlink" title="Vue 底层实现原理"></a><strong>Vue 底层实现原理</strong></h4><p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter 和 getter，在数据变动时发布消息给订阅者，触发相应的监听回调<br>Vue 是一个典型的 MVVM 框架，模型（Model）只是普通的 javascript 对象，修改它则试图（View）会自动更新。这种设计让状态管理变得非常简单而直观</p>
<p><strong>Observer（数据监听器）</strong> : Observer 的核心是通过 Object.defineProprtty()来监听数据的变动，这个函数内部可以定义 setter 和 getter，每当数据发生变化，就会触发 setter。这时候 Observer 就要通知订阅者，订阅者就是 Watcher</p>
<p><strong>Watcher（订阅者）</strong> : Watcher 订阅者作为 Observer 和 Compile 之间通信的桥梁，主要做的事情是：</p>
<ol>
<li>在自身实例化时往属性订阅器(dep)里面添加自己</li>
<li>自身必须有一个 update()方法</li>
<li>待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发 Compile 中绑定的回调</li>
</ol>
<p><strong>Compile（指令解析器）</strong> : Compile 主要做的事情是解析模板指令，将模板中变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加鉴定数据的订阅者，一旦数据有变动，收到通知，更新试图</p>
<h4 id="谈谈对-vue-生命周期的理解？"><a href="#谈谈对-vue-生命周期的理解？" class="headerlink" title="谈谈对 vue 生命周期的理解？"></a><strong>谈谈对 vue 生命周期的理解？</strong></h4><p>每个 Vue 实例在创建时都会经过一系列的初始化过程，vue 的生命周期钩子，就是说在达到某一阶段或条件时去触发的函数，目的就是为了完成一些动作或者事件</p>
<ul>
<li>create 阶段：vue 实例被创建<br>beforeCreate: 创建前，此时 data 和 methods 中的数据都还没有初始化<br>created： 创建完毕，data 中有值，未挂载</li>
<li>mount 阶段： vue 实例被挂载到真实 DOM 节点<br>beforeMount：可以发起服务端请求，去数据<br>mounted: 此时可以操作 DOM</li>
<li>update 阶段：当 vue 实例里面的 data 数据变化时，触发组件的重新渲染<br>beforeUpdate :更新前<br>updated：更新后</li>
<li>destroy 阶段：vue 实例被销毁<br>beforeDestroy：实例被销毁前，此时可以手动销毁一些方法<br>destroyed:销毁后</li>
</ul>
<h4 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a><strong>组件生命周期</strong></h4><p>生命周期（父子组件） 父组件 beforeCreate –&gt; 父组件 created –&gt; 父组件 beforeMount –&gt; 子组件 beforeCreate –&gt; 子组件 created –&gt; 子组件 beforeMount –&gt; 子组件 mounted –&gt; 父组件 mounted –&gt;父组件 beforeUpdate –&gt;子组件 beforeDestroy–&gt; 子组件 destroyed –&gt; 父组件 updated</p>
<p><strong>加载渲染过程</strong> 父 beforeCreate-&gt;父 created-&gt;父 beforeMount-&gt;子 beforeCreate-&gt;子 created-&gt;子 beforeMount-&gt;子 mounted-&gt;父 mounted</p>
<p><strong>挂载阶段</strong> 父 created-&gt;子 created-&gt;子 mounted-&gt;父 mounted</p>
<p><strong>父组件更新阶段</strong> 父 beforeUpdate-&gt;父 updated</p>
<p><strong>子组件更新阶段</strong> 父 beforeUpdate-&gt;子 beforeUpdate-&gt;子 updated-&gt;父 updated</p>
<p><strong>销毁阶段</strong> 父 beforeDestroy-&gt;子 beforeDestroy-&gt;子 destroyed-&gt;父 destroyed</p>
<p><strong>computed 与 watch</strong></p>
<p>通俗来讲，既能用 computed 实现又可以用 watch 监听来实现的功能，推荐用 computed， 重点在于 computed 的缓存功能 computed 计算属性是用来声明式的描述一个值依赖了其它的值，当所依赖的值或者变量 改变时，计算属性也会跟着改变； watch 监听的是已经在 data 中定义的变量，当该变量变化时，会触发 watch 中的方法。</p>
<p><strong>watch 属性监听</strong> 是一个对象，键是需要观察的属性，值是对应回调函数，主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作,监听属性的变化，需要在数据变化时执行异步或开销较大的操作时使用</p>
<p><strong>computed 计算属性</strong> 属性的结果会被缓存，当 computed 中的函数所依赖的属性没有发生改变的时候，那么调用当前函数的时候结果会从缓存中读取。除非依赖的响应式属性变化时才会重新计算，主要当做属性来使用 computed 中的函数必须用 return 返回最终的结果 computed 更高效，优先使用。data 不改变，computed 不更新。</p>
<p><strong>使用场景</strong> computed：当一个属性受多个属性影响的时候使用，例：购物车商品结算功能 watch：当一条数据影响多条数据的时候使用，例：搜索数据</p>
<h4 id="组件中的-data-为什么是一个函数？"><a href="#组件中的-data-为什么是一个函数？" class="headerlink" title="组件中的 data 为什么是一个函数？"></a><strong>组件中的 data 为什么是一个函数？</strong></h4><p>1.一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。 2.如果 data 是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间 data 不冲突，data 必须是一个函数。</p>
<p><strong>为什么 v-for 和 v-if 不建议用在一起</strong></p>
<p>1.当 v-for 和 v-if 处于同一个节点时，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。如果要遍历的数组很大，而真正要展示的数据很少时，这将造成很大的性能浪费（Vue2.x） 2.这种场景建议使用 computed，先对数据进行过滤</p>
<p>注意：3.x 版本中 v-if 总是优先于 v-for 生效。由于语法上存在歧义，建议避免在同一元素上同时使用两者。比起在模板层面管理相关逻辑，更好的办法是通过创建计算属性筛选出列表，并以此创建可见元素。</p>
<p>解惑传送门 ☞ <a class="link"   href="https://link.juejin.cn/?target=https://v3.cn.vuejs.org/guide/migration/v-if-v-for.html%23%25E6%25A6%2582%25E8%25A7%2588" ># v-if 与 v-for 的优先级对比非兼容 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h4 id="React-x2F-Vue-项目中-key-的作用"><a href="#React-x2F-Vue-项目中-key-的作用" class="headerlink" title="React&#x2F;Vue 项目中 key 的作用"></a><strong>React&#x2F;Vue 项目中 key 的作用</strong></h4><ul>
<li>key 的作用是为了在 diff 算法执行时更快的找到对应的节点，提高 diff 速度，更高效的更新虚拟 DOM;</li>
</ul>
<p>vue 和 react 都是采用 diff 算法来对比新旧虚拟节点，从而更新节点。在 vue 的 diff 函数中，会根据新节点的 key 去对比旧节点数组中的 key，从而找到相应旧节点。如果没找到就认为是一个新增节点。而如果没有 key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个 map 映射，另一种是遍历查找。相比而言。map 映射的速度更快。</p>
<ul>
<li>为了在数据变化时强制更新组件，以避免“就地复用”带来的副作用。</li>
</ul>
<p>当 Vue.js 用 v-for 更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。重复的 key 会造成渲染错误。</p>
<h4 id="vue-组件的通信方式"><a href="#vue-组件的通信方式" class="headerlink" title="vue 组件的通信方式"></a><strong>vue 组件的通信方式</strong></h4><ul>
<li>props&#x2F;$emit 父子组件通信</li>
</ul>
<p>父-&gt;子 props，子-&gt;父 $on、$emit 获取父子组件实例 parent、children Ref 获取实例的方式调用组件的属性或者方法 父-&gt;子孙 Provide、inject 官方不推荐使用，但是写组件库时很常用</p>
<ul>
<li>$emit&#x2F;$on 自定义事件 兄弟组件通信</li>
</ul>
<p>Event Bus 实现跨组件通信 Vue.prototype.$bus &#x3D; new Vue() 自定义事件</p>
<ul>
<li>vuex 跨级组件通信</li>
</ul>
<p>Vuex、$attrs、$listeners Provide、inject</p>
<h4 id="nextTick-的实现"><a href="#nextTick-的实现" class="headerlink" title="nextTick 的实现"></a><strong>nextTick 的实现</strong></h4><ol>
<li>nextTick 是 Vue 提供的一个全局 API,是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用$nextTick，则可以在回调中获取更新后的 DOM；</li>
<li>Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启 1 个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中-次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。nextTick 方法会在队列中加入一个回调函数，确保该函数在前面的 dom 操作完成后才调用；</li>
<li>比如，我在干什么的时候就会使用 nextTick，传一个回调函数进去，在里面执行 dom 操作即可；</li>
<li>我也有简单了解 nextTick 实现，它会在 callbacks 里面加入我们传入的函数，然后用 timerFunc 异步方式调用它们，首选的异步方式会是 Promise。这让我明白了为什么可以在 nextTick 中看到 dom 操作结果。</li>
</ol>
<h4 id="nextTick-的实现原理是什么？"><a href="#nextTick-的实现原理是什么？" class="headerlink" title="nextTick 的实现原理是什么？"></a><strong>nextTick 的实现原理是什么？</strong></h4><p>在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后立即使用 nextTick 来获取更新后的 DOM。 nextTick 主要使用了宏任务和微任务。 根据执行环境分别尝试采用 Promise、MutationObserver、setImmediate，如果以上都不行则采用 setTimeout 定义了一个异步方法，多次调用 nextTick 会将方法存入队列中，通过这个异步方法清空当前队列。</p>
<h4 id="使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽"><a href="#使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽" class="headerlink" title="使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽"></a><strong>使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽</strong></h4><p>vue 中的插槽是一个非常好用的东西 slot 说白了就是一个占位的 在 vue 当中插槽包含三种一种是默认插槽（匿名）一种是具名插槽还有一种就是作用域插槽 匿名插槽就是没有名字的只要默认的都填到这里具名插槽指的是具有名字的</p>
<h4 id="keep-alive-的实现"><a href="#keep-alive-的实现" class="headerlink" title="keep-alive 的实现"></a><strong>keep-alive 的实现</strong></h4><p>作用：实现组件缓存，保持这些组件的状态，以避免反复渲染导致的性能问题。 需要缓存组件 频繁切换，不需要重复渲染</p>
<p>场景：tabs 标签页 后台导航，vue 性能优化</p>
<p>原理：Vue.js 内部将 DOM 节点抽象成了一个个的 VNode 节点，keep-alive 组件的缓存也是基于 VNode 节点的而不是直接存储 DOM 结构。它将满足条件（pruneCache 与 pruneCache）的组件在 cache 对象中缓存起来，在需要重新渲染的时候再将 vnode 节点从 cache 对象中取出并渲染。</p>
<p><strong>mixin</strong></p>
<p>mixin 项目变得复杂的时候，多个组件间有重复的逻辑就会用到 mixin<br>多个组件有相同的逻辑，抽离出来<br>mixin 并不是完美的解决方案，会有一些问题<br>vue3 提出的 Composition API 旨在解决这些问题【追求完美是要消耗一定的成本的，如开发成本】<br>场景：PC 端新闻列表和详情页一样的右侧栏目，可以使用 mixin 进行混合<br>劣势：1.变量来源不明确，不利于阅读 2.多 mixin 可能会造成命名冲突 3.mixin 和组件可能出现多对多的关系，使得项目复杂度变高</p>
<h4 id="Vuex-的理解及使用场景"><a href="#Vuex-的理解及使用场景" class="headerlink" title="Vuex 的理解及使用场景"></a><strong>Vuex 的理解及使用场景</strong></h4><p>Vuex 是一个专为 Vue 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。</p>
<ol>
<li>Vuex 的状态存储是响应式的；当 Vue 组件从 store 中读取状态的时候，</li>
</ol>
<p>若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新 2. 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation， 这样使得我们可以方便地跟踪每一个状态的变化 Vuex 主要包括以下几个核心模块：</p>
<ol>
<li>State：定义了应用的状态数据</li>
<li>Getter：在 store 中定义“getter”（可以认为是 store 的计算属性），</li>
</ol>
<p>就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来， 且只有当它的依赖值发生了改变才会被重新计算 3. Mutation：是唯一更改 store 中状态的方法，且必须是同步函数 4. Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作 5. Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中</p>
<h4 id="hooks-用过吗？聊聊-react-中-class-组件和函数组件的区别"><a href="#hooks-用过吗？聊聊-react-中-class-组件和函数组件的区别" class="headerlink" title="hooks 用过吗？聊聊 react 中 class 组件和函数组件的区别"></a><strong>hooks 用过吗？聊聊 react 中 class 组件和函数组件的区别</strong></h4><p>类组件是使用 ES6 的 class 来定义的组件。 函数组件是接收一个单一的 props 对象并返回一个 React 元素。</p>
<p>关于 React 的两套 API（类（class）API 和基于函数的钩子（hooks） API）。官方推荐使用钩子（函数），而不是类。因为钩子更简洁，代码量少，用起来比较”轻”，而类比较”重”。而且，钩子是函数，更符合 React 函数式的本质。</p>
<p>函数一般来说，只应该做一件事，就是返回一个值。 如果你有多个操作，每个操作应该写成一个单独的函数。而且，数据的状态应该与操作方法分离。根据函数这种理念，React 的函数组件只应该做一件事情：返回组件的 HTML 代码，而没有其他的功能。函数的返回结果只依赖于它的参数。不改变函数体外部数据、函数执行过程里面没有副作用。</p>
<p>类（class）是数据和逻辑的封装。 也就是说，组件的状态和操作方法是封装在一起的。如果选择了类的写法，就应该把相关的数据和操作，都写在同一个 class 里面。</p>
<p><strong>类组件的缺点</strong> :</p>
<p>大型组件很难拆分和重构，也很难测试。<br>业务逻辑分散在组件的各个方法之中，导致重复逻辑或关联逻辑。<br>组件类引入了复杂的编程模式，比如 render props 和高阶组件。<br>难以理解的 class，理解 JavaScript 中 this 的工作方式。</p>
<p><strong>区别</strong>：</p>
<p>函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。</p>
<p>1.状态的有无<br>hooks 出现之前，函数组件没有实例，没有生命周期，没有 state，没有 this，所以我们称函数组件为无状态组件。 hooks 出现之前，react 中的函数组件通常只考虑负责 UI 的渲染，没有自身的状态没有业务逻辑代码，是一个纯函数。它的输出只由参数 props 决定，不受其他任何因素影响。</p>
<p>2.调用方式的不同<br>函数组件重新渲染，将重新调用组件方法返回新的 react 元素。类组件重新渲染将 new 一个新的组件实例，然后调用 render 类方法返回 react 元素，这也说明为什么类组件中 this 是可变的。</p>
<p>3.因为调用方式不同，在函数组件使用中会出现问题<br>在操作中改变状态值，类组件可以获取最新的状态值，而函数组件则会按照顺序返回状态值</p>
<p><strong>React Hooks（钩子的作用）</strong></p>
<p><em>Hook</em> 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p>
<p>React Hooks 的几个常用钩子:</p>
<ol>
<li>useState() &#x2F;&#x2F;状态钩子</li>
<li>useContext() &#x2F;&#x2F;共享状态钩子</li>
<li>useReducer() &#x2F;&#x2F;action 钩子</li>
<li>useEffect() &#x2F;&#x2F;副作用钩子</li>
</ol>
<p>还有几个不常见的大概的说下，后续会专门写篇文章描述下</p>
<ul>
<li>1.useCallback 记忆函数 一般把<strong>函数式组件理解为 class 组件 render 函数的语法糖</strong>，所以每次重新渲染的时候，函数式组件内部所有的代码都会重新执行一遍。而有了 useCallback 就不一样了，你可以通过 useCallback 获得一个记忆后的函数。</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> memoizedHandleClick = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Click happened&#x27;</span>)</span><br><span class="line">  &#125;, []) <span class="comment">// 空数组代表无论什么情况下该函数都不会发生改变</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">SomeComponent</span> <span class="attr">onClick</span>=<span class="string">&#123;memoizedHandleClick&#125;</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">SomeComponent</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>第二个参数传入一个数组，数组中的每一项一旦值或者引用发生改变，useCallback 就会重新返回一个新的记忆函数提供给后面进行渲染。</p>
<ul>
<li>2.useMemo 记忆组件 useCallback 的功能完全可以由 useMemo 所取代，如果你想通过使用 useMemo 返回一个记忆函数也是完全可以的。 唯一的区别是：<strong>useCallback 不会执行第一个参数函数，而是将它返回给你，而 useMemo 会执行第一个函数并且将函数执行结果返回给你</strong>。<br>所以 useCallback 常用记忆事件函数，生成记忆后的事件函数并传递给子组件使用。而 useMemo 更适合经过函数计算得到一个确定的值，比如记忆组件。</li>
<li>3.useRef 保存引用值</li>
</ul>
<p>useRef 跟 createRef 类似，都可以用来生成对 DOM 对象的引用。useRef 返回的值传递给组件或者 DOM 的 ref 属性，就可以通过 ref.current 值<strong>访问组件或真实的 DOM 节点，重点是组件也是可以访问到的</strong>，从而可以对 DOM 进行一些操作，比如监听事件等等。</p>
<ul>
<li>4.useImperativeHandle 穿透 Ref</li>
</ul>
<p>通过 useImperativeHandle 用于让父组件获取子组件内的索引</p>
<ul>
<li>5.useLayoutEffect 同步执行副作用</li>
</ul>
<p>大部分情况下，使用 useEffect 就可以帮我们处理组件的副作用，但是如果想要同步调用一些副作用，比如对 DOM 的操作，就需要使用 useLayoutEffect，useLayoutEffect 中的副作用会在 DOM 更新之后同步执行。</p>
<p><strong>useEffect 和 useLayoutEffect 有什么区别</strong>：简单来说就是调用时机不同，useLayoutEffect 和原来 componentDidMount&amp;componentDidUpdate 一致，在 react 完成 DOM 更新后马上同步调用的代码，会阻塞页面渲染。而 useEffect 是会在整个页面渲染完才会调用的代码。官方建议优先使用 useEffect</p>
<h4 id="React-组件通信方式"><a href="#React-组件通信方式" class="headerlink" title="React 组件通信方式"></a><strong>React 组件通信方式</strong></h4><p>react 组件间通信常见的几种情况:</p>
<ul>
<li>父组件向子组件通信</li>
<li>子组件向父组件通信</li>
<li>跨级组件通信</li>
<li>非嵌套关系的组件通信</li>
</ul>
<p><strong>1）父组件向子组件通信</strong></p>
<p>父组件通过 props 向子组件传递需要的信息。父传子是在父组件中直接绑定一个正常的属性，这个属性就是指具体的值，在子组件中，用 props 就可以获取到这个值</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件: Child</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Child</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;props.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父组件 Parent</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Parent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">name</span>=<span class="string">&quot;京程一灯&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>2）子组件向父组件通信</strong></p>
<p>props+回调的方式，使用公共组件进行状态提升。子传父是先在父组件上绑定属性设置为一个函数，当子组件需要给父组件传值的时候，则通过 props 调用该函数将参数传入到该函数当中，此时就可以在父组件中的函数中接收到该参数了，这个参数则为子组件传过来的值</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件: Child</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Child</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">cb</span> = (<span class="params">msg</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      props.<span class="title function_">callback</span>(msg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;cb(</span>&#x27;<span class="attr">京程一灯欢迎你</span>!&#x27;)&#125;&gt;</span>京程一灯欢迎你<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件 Parent</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">callback</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">callback</span>=<span class="string">&#123;this.callback.bind(this)&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>3）跨级组件通信</strong></p>
<p>即父组件向子组件的子组件通信，向更深层子组件通信。</p>
<ul>
<li>使用 props，利用中间组件层层传递,但是如果父组件结构较深，那么中间每一层组件都要去传递 props，增加了复杂度，并且这些 props 并不是中间组件自己需要的。</li>
<li>使用 context，context 相当于一个大容器，我们可以把要通信的内容放在这个容器中，这样不管嵌套多深，都可以随意取用，对于跨越多层的全局数据可以使用 context 实现。</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// context 方式实现跨级组件通信</span></span><br><span class="line"><span class="comment">// Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">BatteryContext</span> = <span class="title function_">createContext</span>()</span><br><span class="line"><span class="comment">// 子组件的子组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandChild</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">BatteryContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;(color) =&gt; <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> <span class="attr">color</span> &#125;&#125;&gt;</span>我是红色的:&#123;color&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">BatteryContext.Consumer</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = () =\&gt;&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">\&lt;<span class="title class_">GrandChild</span>/\&gt;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; color &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">BatteryContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;color&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Child</span>&gt;</span><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">BatteryContext.Provider</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>4）非嵌套关系的组件通信</strong></p>
<p>即没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。</p>
<ul>
<li>可以使用自定义事件通信（发布订阅模式），使用 pubsub-js</li>
<li>可以通过 redux 等进行全局状态管理</li>
<li>如果是兄弟组件通信，可以找到这两个兄弟节点共同的父节点, 结合父子间通信方式进行通信。</li>
<li>也可以 new 一个 Vue 的 EventBus,进行事件监听，一边执行监听，一边执行新增 VUE 的 eventBus 就是发布订阅模式，是可以在 React 中使用的;</li>
</ul>
<h4 id="setState-既存在异步情况也存在同步情况"><a href="#setState-既存在异步情况也存在同步情况" class="headerlink" title="setState 既存在异步情况也存在同步情况"></a><strong>setState 既存在异步情况也存在同步情况</strong></h4><p>1.异步情况 在 React 事件当中是异步操作</p>
<p>2.同步情况 如果是在 setTimeout 事件或者自定义的 dom 事件中，都是同步的</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//setTimeout 事件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>,&#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Count</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span>&#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line"><span class="variable language_">super</span>(props);</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line"><span class="attr">count</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>count:&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.btnAction&#125;</span>&gt;</span>增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">btnAction = ()=\&gt;&#123;</span><br><span class="line"><span class="comment">//不能直接修改 state，需要通过 setState 进行修改</span></span><br><span class="line"><span class="comment">//同步</span></span><br><span class="line"><span class="built_in">setTimeout</span>(()=\&gt;&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line"><span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Count</span>;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义 dom 事件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>,&#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Count</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span>&#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line"><span class="variable language_">super</span>(props);</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line"><span class="attr">count</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>count:&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>绑定点击事件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/&gt;</span></span></span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义 dom 事件，也是同步修改</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;\#btn&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,()=\&gt;&#123;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line"></span><br><span class="line"><span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Count</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a><strong>生命周期</strong></h4><p>安装</p>
<p>当组件的实例被创建并插入到 DOM 中时，这些方法按以下顺序调用：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>()</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>()</span><br><span class="line"></span><br><span class="line"><span class="title function_">componentDidMount</span>()</span><br><span class="line"></span><br><span class="line">更新中</span><br><span class="line"></span><br><span class="line">更新可能由道具或状态的更改引起。当重新渲染组件时，这些方法按以下顺序调用：</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>()</span><br><span class="line"></span><br><span class="line"><span class="title function_">shouldComponentUpdate</span>()</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>()</span><br><span class="line"></span><br><span class="line"><span class="title function_">getSnapshotBeforeUpdate</span>()</span><br><span class="line"></span><br><span class="line"><span class="title function_">componentDidUpdate</span>()</span><br><span class="line"></span><br><span class="line">卸载</span><br><span class="line"></span><br><span class="line">当组件从 <span class="variable constant_">DOM</span> 中移除时调用此方法：</span><br><span class="line"></span><br><span class="line"><span class="title function_">componentWillUnmount</span>()</span><br></pre></td></tr></table></figure></div>

<h4 id="说一下-react-fiber"><a href="#说一下-react-fiber" class="headerlink" title="说一下 react-fiber"></a><strong>说一下 react-fiber</strong></h4><p><strong>1）背景</strong></p>
<p>react-fiber 产生的根本原因，是大量的同步计算任务阻塞了浏览器的 UI 渲染。默认情况下，JS 运算、页面布局和页面绘制都是运行在浏览器的主线程当中，他们之间是互斥的关系。如果 JS 运算持续占用主线程，页面就没法得到及时的更新。当我们调用 setState 更新页面的时候，React 会遍历应用的所有节点，计算出差异，然后再更新 UI。如果页面元素很多，整个过程占用的时机就可能超过 16 毫秒，就容易出现掉帧的现象。</p>
<p><strong>2）实现原理</strong></p>
<ul>
<li>react 内部运转分三层：</li>
<li>Virtual DOM 层，描述页面长什么样。</li>
<li>Reconciler 层，负责调用组件生命周期方法，进行 Diff 运算等。</li>
<li>Renderer 层，根据不同的平台，渲染出相应的页面，比较常见的是 ReactDOM 和 ReactNative。</li>
</ul>
<p>Fiber 其实指的是一种数据结构，它可以用一个纯 JS 对象来表示：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fiber = &#123;</span><br><span class="line">stateNode, <span class="comment">// 节点实例</span></span><br><span class="line">child, <span class="comment">// 子节点</span></span><br><span class="line">sibling, <span class="comment">// 兄弟节点</span></span><br><span class="line"><span class="keyword">return</span>, <span class="comment">// 父节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>为了实现不卡顿，就需要有一个调度器 (Scheduler) 来进行任务分配。优先级高的任务（如键盘输入）可以打断优先级低的任务（如 Diff）的执行，从而更快的生效。任务的优先级有六种：</li>
<li>synchronous，与之前的 Stack Reconciler 操作一样，同步执行</li>
<li>task，在 next tick 之前执行</li>
<li>animation，下一帧之前执行</li>
<li>high，在不久的将来立即执行</li>
<li>low，稍微延迟执行也没关系</li>
<li>offscreen，下一次 render 时或 scroll 时才执行</li>
<li>Fiber Reconciler（react ）执行过程分为 2 个阶段：</li>
<li>阶段一，生成 Fiber 树，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断。阶段一可被打断的特性，让优先级更高的任务先执行，从框架层面大大降低了页面掉帧的概率。</li>
<li>阶段二，将需要更新的节点一次过批量更新，这个过程不能被打断。</li>
<li>Fiber 树：React 在 render 第一次渲染时，会通过 React.createElement 创建一颗 Element 树，可以称之为 Virtual DOM Tree，由于要记录上下文信息，加入了 Fiber，每一个 Element 会对应一个 Fiber Node，将 Fiber Node 链接起来的结构成为 Fiber Tree。Fiber Tree 一个重要的特点是链表结构，将递归遍历编程循环遍历，然后配合 requestIdleCallback API, 实现任务拆分、中断与恢复。</li>
</ul>
<p>从 Stack Reconciler 到 Fiber Reconciler，源码层面其实就是干了一件递归改循环的事情</p>
<h4 id="Portals"><a href="#Portals" class="headerlink" title="Portals"></a><strong>Portals</strong></h4><p>Portals 提供了一种一流的方式来将子组件渲染到存在于父组件的 DOM 层次结构之外的 DOM 节点中。结构不受外界的控制的情况下就可以使用 portals 进行创建</p>
<h4 id="何时要使用异步组件？如和使用异步组件"><a href="#何时要使用异步组件？如和使用异步组件" class="headerlink" title="何时要使用异步组件？如和使用异步组件"></a><strong>何时要使用异步组件？如和使用异步组件</strong></h4><ul>
<li>加载大组件的时候</li>
<li>路由异步加载的时候</li>
</ul>
<p>react 中要配合 Suspense 使用</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步懒加载</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Box</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./components/Box&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用组件的时候要用 suspense 进行包裹</span></span><br><span class="line"></span><br><span class="line">;<span class="language-xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;&#123;show &amp;&amp; <span class="tag">&lt;<span class="name">Box</span> /&gt;</span>&#125;<span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<h4 id="React-事件绑定原理"><a href="#React-事件绑定原理" class="headerlink" title="React 事件绑定原理"></a><strong>React 事件绑定原理</strong></h4><p>React 并不是将 click 事件绑在该 div 的真实 DOM 上，而是在 document 处监听所有支持的事件，当事件发生并冒泡至 document 处时，React 将事件内容封装并交由真正的处理函数运行。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。<br>另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 event.preventDefault。</p>
<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a><strong>webpack</strong></h2><h4 id="webpack-做过哪些优化，开发效率方面、打包策略方面等等"><a href="#webpack-做过哪些优化，开发效率方面、打包策略方面等等" class="headerlink" title="webpack 做过哪些优化，开发效率方面、打包策略方面等等"></a><strong>webpack 做过哪些优化，开发效率方面、打包策略方面等等</strong></h4><p><strong>1）优化 Webpack 的构建速度</strong></p>
<ul>
<li>使用高版本的 Webpack （使用 webpack4）</li>
<li>多线程&#x2F;多实例构建：HappyPack(不维护了)、thread-loader</li>
<li>缩小打包作用域：</li>
<li>exclude&#x2F;include (确定 loader 规则范围)</li>
<li>resolve.modules 指明第三方模块的绝对路径 (减少不必要的查找)</li>
<li>resolve.extensions 尽可能减少后缀尝试的可能性</li>
<li>noParse 对完全不需要解析的库进行忽略 (不去解析但仍会打包到 bundle 中，注意被忽略掉的文件里不应该包含 import、require、define 等模块化语句)</li>
<li>IgnorePlugin (完全排除模块)</li>
<li>合理使用 alias</li>
<li>充分利用缓存提升二次构建速度：</li>
<li>babel-loader 开启缓存</li>
<li>terser-webpack-plugin 开启缓存</li>
<li>使用 cache-loader 或者 hard-source-webpack-plugin<br>注意：thread-loader 和 cache-loader 兩個要一起使用的話，請先放 cache-loader 接著是 thread-loader 最後才是 heavy-loader</li>
<li>DLL：</li>
<li>使用 DllPlugin 进行分包，使用 DllReferencePlugin(索引链接) 对 manifest.json 引用，让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间。 2）使用 webpack4-优化原因</li>
<li>(a)V8 带来的优化（for of 替代 forEach、Map 和 Set 替代 Object、includes 替代 indexOf）</li>
<li>(b)默认使用更快的 md4 hash 算法</li>
<li>(c)webpacks AST 可以直接从 loader 传递给 AST，减少解析时间</li>
<li>(d)使用字符串方法替代正则表达式 ①noParse</li>
<li>不去解析某个库内部的依赖关系</li>
<li>比如 jquery 这个库是独立的， 则不去解析这个库内部依赖的其他的东西</li>
<li>在独立库的时候可以使用</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">noParse</span>: <span class="regexp">/jquery/</span>,</span><br><span class="line">    <span class="attr">rules</span>: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>②IgnorePlugin</p>
<ul>
<li>忽略掉某些内容 不去解析依赖库内部引用的某些内容</li>
<li>从 moment 中引用 .&#x2F;locol 则忽略掉</li>
<li>如果要用 local 的话 则必须在项目中必须手动引入</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;moment/locale/zh-cn&#x27;</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Webpack</span>.<span class="title class_">IgnorePlugin</span>(<span class="regexp">/./</span>local/, <span class="regexp">/moment/</span>),</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>③dillPlugin</p>
<ul>
<li>不会多次打包， 优化打包时间</li>
<li>先把依赖的不变的库打包</li>
<li>生成 manifest.json 文件</li>
<li>然后在 webpack.config 中引入</li>
<li>webpack.DllPlugin Webpack.DllReferencePlugin ④happypack -&gt; thread-loader</li>
<li>大项目的时候开启多线程打包</li>
<li>影响前端发布速度的有两个方面，一个是构建，一个就是压缩，把这两个东西优化起来，可以减少很多发布的时间。 ⑤thread-loader<br>thread-loader 会将您的 loader 放置在一个 worker 池里面运行，以达到多线程构建。<br>把这个 loader 放置在其他 loader 之前（如下图 example 的位置）， 放置在这个 loader 之后的 loader 就会在一个单独的 worker 池(worker pool)中运行。</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/.js\$/</span>,</span><br><span class="line">        <span class="attr">include</span>: path.<span class="title function_">resolve</span>(<span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          <span class="string">&#x27;thread-loader&#x27;</span></span><br><span class="line">          <span class="comment">// 你的高开销的 loader 放置在此 (e.g babel-loader)</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>每个 worker 都是一个单独的有 600ms 限制的 node.js 进程。同时跨进程的数据交换也会被限制。请在高开销的 loader 中使用，否则效果不佳</p>
<p>⑥ 压缩加速——开启多线程压缩</p>
<ul>
<li>不推荐使用 webpack-paralle-uglify-plugin，项目基本处于没人维护的阶段，issue 没人处理，pr 没人合并。<br>Webpack 4.0 以前：uglifyjs-webpack-plugin，parallel 参数</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">minimizer</span>: [</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">UglifyJsPlugin</span>(&#123;</span><br><span class="line">        <span class="attr">parallel</span>: <span class="literal">true</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>推荐使用 terser-webpack-plugin</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"><span class="attr">optimization</span>: &#123;</span><br><span class="line"><span class="attr">minimizer</span>: [<span class="keyword">new</span> <span class="title class_">TerserPlugin</span>(</span><br><span class="line"><span class="attr">parallel</span>: <span class="literal">true</span> <span class="comment">// 多线程</span></span><br><span class="line">)],</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><strong>2）优化 Webpack 的打包体积</strong></p>
<ul>
<li>压缩代码</li>
<li>提取页面公共资源：</li>
<li>Tree shaking</li>
<li>Scope hoisting</li>
<li>图片压缩</li>
<li>动态 Polyfill <strong>3）speed-measure-webpack-plugin</strong><br>简称 SMP，分析出 Webpack 打包过程中 Loader 和 Plugin 的耗时，有助于找到构建过程中的性能瓶颈。 <strong>开发阶段</strong></li>
</ul>
<p>开启多核压缩 插件：** terser-webpack-plugin **</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">TerserPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;terser-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">minimizer</span>: [</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">TerserPlugin</span>(&#123;</span><br><span class="line">        <span class="attr">parallel</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">terserOptions</span>: &#123;</span><br><span class="line">          <span class="attr">ecma</span>: <span class="number">6</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a><strong>Babel</strong></h2><h4 id="简单描述一下-Babel-的编译过程"><a href="#简单描述一下-Babel-的编译过程" class="headerlink" title="简单描述一下 Babel 的编译过程"></a><strong>简单描述一下 Babel 的编译过程</strong></h4><p>Babel 是一个 JavaScript 编译器，是一个工具链，主要用于将采用 ECMAScript 2015+ 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。</p>
<p>Babel 本质上就是在操作 AST 来完成代码的转译。AST 是抽象语法树（Abstract Syntax Tree, AST）</p>
<p>Babel 的功能很纯粹，它只是一个编译器。大多数编译器的工作过程可以分为三部分：</p>
<ol>
<li><strong>解析（Parse）</strong> ：将源代码转换成更加抽象的表示方法（例如抽象语法树）。包括词法分析和语法分析。词法分析主要把字符流源代码（Char Stream）转换成令牌流（ Token Stream），语法分析主要是将令牌流转换成抽象语法树（Abstract Syntax Tree，AST）。</li>
<li><strong>转换（Transform）</strong> ：通过 Babel 的插件能力，对（抽象语法树）做一些特殊处理，将高版本语法的 AST 转换成支持低版本语法的 AST。让它符合编译器的期望，当然在此过程中也可以对 AST 的 Node 节点进行优化操作，比如添加、更新以及移除节点等。</li>
<li><strong>生成（Generate）</strong> ：将 AST 转换成字符串形式的低版本代码，同时也能创建 Source Map 映射。</li>
</ol>
<p>经过这三个阶段，代码就被 Babel 转译成功了。</p>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a><strong>Git</strong></h2><h4 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a><strong>Git 常用命令</strong></h4><p>查看分支：git branch<br>创建分支：git branch<br>切换分支：git checkout<br>创建+切换分支：git checkout -b<br>合并某分支到当前分支：git merge<br>删除分支：git branch -d</p>
<h4 id="如何使用-Git-管理项目"><a href="#如何使用-Git-管理项目" class="headerlink" title="如何使用 Git 管理项目"></a><strong>如何使用 Git 管理项目</strong></h4><p>实际开发中，一个仓库（一般只放一个项目）主要存在两条主分支：master 与 develop 分支。这个两个分支的生命周期是整个项目周期。</p>
<p>我们可能使用的不同类型的分支对项目进行管理是：</p>
<ul>
<li>功能分支 功能分支（或有时称为主题分支）用于为即将发布或遥远的未来版本开发新功能。在开始开发某个功能时，将包含该功能的目标版本在那时很可能是未知的。功能分支的本质在于，只要该功能处于开发阶段，它就存在，但最终会被合并回 develop（明确将新功能添加到即将发布的版本中）或丢弃。功能分支通常只存在于开发者仓库中，而不存在于 origin。</li>
<li>发布分支 发布分支支持准备新的生产版本。它们允许在最后一刻打点 i 和交叉 t。此外，它们允许修复小错误并为发布准备元数据（版本号、构建日期等）。通过在发布分支上完成所有这些工作，该 develop 分支被清除以接收下一个大版本的功能。</li>
<li>从 develop 分支拉取，且必须合并回 develop 和 master</li>
<li>分支命名约定：release-*</li>
<li>修补程序分支</li>
</ul>
<p>Hotfix 分支与发布分支非常相似，因为它们也旨在为新的生产版本做准备，尽管是计划外的。它们产生于需要立即对现场制作版本的不良状态采取行动。当必须立即解决生产版本中的关键错误时，可以从标记生产版本的主分支上的相应标记中分支出一个修补程序分支。</p>
<p><strong>master</strong>：这个分支最为稳定，这个分支表明项目处于可发布的状态。<br><strong>develop</strong>：做为开发的分支，平行于 master 分支。<br><strong>Feature branches</strong>：这种分支和咱们程序员平常开发最为密切，称做功能分支。必须从 develop 分支建立，完成后合并回 develop 分支。<br><strong>Release branches</strong>：这个分支用来分布新版本。从 develop 分支建立，完成后合并回 develop 与 master 分支。这个分支上能够作一些很是小的 bug 修复，固然，你也能够禁止在这个分支作任何 bug 的修复工做，而只作版本发布的相关操做，例如设置版本号等操做，那样的话那些发现的小 bug 就必须放到下一个版本修复了。若是在这个分支上发现了大 bug，那么也绝对不能在这个分支上改，须要 Featrue 分支上改，走正常的流程。<br><strong>Hotfix branches</strong>：这个分支主要为修复线上特别紧急的 bug 准备的。必须从 master 分支建立，完成后合并回 develop 与 master 分支。这个分支主要是解决线上版本的紧急 bug 修复的，例如忽然版本 V0.1 上有一个致命 bug，必须修复。那么咱们就能够从 master 分支上发布这个版本那个时间点 例如 tag v0.1（通常代码发布后会及时在 master 上打 tag），来建立一个 hotfix-v0.1.1 的分支，而后在这个分支上改 bug，而后发布新的版本。最后将代码合并回 develop 与</p>
<h2 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a><strong>项目优化</strong></h2><p>移除生产环境的控制台打印。方案很多，esling+pre-commit、使用插件自动去除，插件包括 babel-plugin-transform-remove-console、uglifyjs-webpack-plugin、terser-webpack-plugin。最后选择了 terser-webpack-plugin，脚手架 vue-cli 用这个插件来开启缓存和多线程打包，无需安装额外的插件，仅需在 configureWebpack 中设置 terser 插件的 drop_console 为 true 即可。最好还是养成良好的代码习惯，在开发基本完成后去掉无用的 console，vscode 中的 turbo console 就蛮好的。</p>
<p>第三方库的按需加载。echarts，官方文档里是使用配置文件指定使用的模块，另一种使用 babel-plugin-equire 实现按需加载。element-ui 使用 babel-plugin-component 实现按需引入。</p>
<p>前后端数据交换方面，推动项目组使用蓝湖、接口文档，与后端同学协商，规范后台数据返回。</p>
<p>雅虎军规提到的，避免 css 表达式、滤镜，较少 DOM 操作，优化图片、精灵图，避免图片空链接等。</p>
<p>性能问题：页面加载性能、动画性能、操作性能。Performance API，记录性能数据。</p>
<p>winter 重学前端 优化技术方案：</p>
<p>缓存：客户端控制的强缓存策略。</p>
<p>降低请求成本：DNS 由客户端控制，隔一段时间主动请求获取域名 IP，不走系统 DNS（完全看不懂）。TCP&#x2F;TLS 连接复用，服务器升级到 HTTP2，尽量合并域名。</p>
<p>减少请求数：JS、CSS 打包到 HTML。JS 控制图片异步加载、懒加载。小型图片使用 data-uri。</p>
<p>较少传输体积：尽量使用 SVG\gradient 代替图片。根据机型和网络状况控制图片清晰度。对低清晰度图片使用锐化来提升体验。设计上避免大型背景图。</p>
<p>使用 CDN 加速，内容分发网络，是建立再承载网基础上的虚拟分布式网络，能够将源站内容缓存到全国或全球的节点服务器上。用户就近获取内容，提高了资源的访问速度，分担源站压力。</p>
]]></content>
  </entry>
</search>
